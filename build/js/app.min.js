/**
 * Editor package.
 * 
 * This package is independent from the application, and represent the graph
 * (canvas element) and logic part of the editor. For organization purposes, 
 * the editor is divided into several namespaces:
 *
 * - **b3e**         : contains all base classes, functions and constants;
 * - **b3e.draw**    : contains functions to draw the block shapes and symbols;
 * - **b3e.editor**  : contains the editor class, editor-related managers and 
 *                     symbols;
 * - **b3e.project** : contains the project class and project-related managers;
 * - **b3e.tree**    : contains the tree class and tree-related managers;
 *
 * As a general rule, an application has a single editor instance; the editor
 * can handle several projects but only a single project can be active in a 
 * given time; a project can have several trees.
 *
 * Each project has a set of nodes (default fixed nodes and custom nodes). A 
 * block is a visual instance of a node.
 *
 * Also notice that, the Editor, Project, Tree, Block, Connection and 
 * SelectionBox are all children of `createjs.DisplayObject` or 
 * `createjs.Container`.
 * 
 */

window.b3e         = window.b3e || {};
window.b3e.draw    = window.b3e.draw || {};
window.b3e.editor  = window.b3e.editor || {};
window.b3e.project = window.b3e.project || {};
window.b3e.tree    = window.b3e.tree || {};


window.b3e.VERSION = '0.3.0';
/** @module b3e */

(function () {
  "use strict";

  /**
   * The Block is an instance of a Node that is drawn into the canvas.
   *
   * @class Block
   * @constructor
   * @param {Object} node A `b3e.Node` object.
   */
  var Block = function(node) {
    this.Container_constructor();

    var dict = node.prototype || node;
    this.id          = b3.createUUID();
    this.node        = node;
    this.name        = dict.name;
    this.title       = dict.title || this.name;
    this.category    = dict.category;
    this.description = dict.description || '';
    this.properties  = tine.merge({}, dict.properties);

    this._settings = null;
    this._inConnection = null;
    this._outConnections = [];
    this._isSelected = null;
    this._isDragging = null;
    this._dragOffsetX = null;
    this._dragOffsetY = null;
    this._width = null;
    this._height = null;
    this._displayShape = new createjs.Shape();
    this._displaySymbol = null;
    this._displayShadow = null;
  };
  var p = createjs.extend(Block, createjs.Container);
  
  /**
   * Apply the editor settings to this block.
   *
   * @method _applySettings
   * @param Object {b3e.SettingsManager} The settings object.
   * @protected
   */
  p._applySettings = function(settings) {
    this._settings = settings;

    var color = this._settings.get('selection_color');
    this._displayShadow = new createjs.Shadow(color, 0, 0, 5);
    this._redraw();
  };

  /**
   * Redraw the block.
   *
   * @method _redraw
   * @protected
   */
  p._redraw = function() {
    var name = this.name;
    var category = this.category.toLowerCase();
    var shape = b3e.draw.SHAPES[category];
    var symbol = b3e.draw.SYMBOLS[name] || b3e.draw.textSymbol;

    this._width = this._settings.get('block_'+category+'_width');
    this._height = this._settings.get('block_'+category+'_height');
    this.removeAllChildren();

    this._displaySymbol = symbol(this, this._settings);
    this._displayShape.graphics.clear();
    this._displayShape = shape(this, this._settings);

    this.addChild(this._displayShape);
    this.addChild(this._displaySymbol);
  };

  /**
   * Copy this block.
   *
   * @method _copy
   * @returns {b3e.Block} A copy of this block.
   * @protected
   */
  p._copy = function() {
    var block = new b3e.Block(this.node);

    block.category    = this.category;
    block.title       = this.title;
    block.description = this.description;
    block.properties  = tine.merge({}, this.properties);
    
    block._applySettings(this._settings);
    block.x           = this.x;
    block.y           = this.y;


    return block;
  };

  /**
   * Snap the block according to the snap settings.
   *
   * @method _snap
   * @protected
   */
  p._snap = function() {
    var snap_x = this._settings.get('snap_x');
    var snap_y = this._settings.get('snap_y');
    var dx = this.x%snap_x;
    var dy = this.y%snap_y;

    if (dx < 0) dx = snap_x+dx;
    if (dy < 0) dy = snap_y+dy;

    this.x -= dx;
    this.y -= dy;
  };

  /**
   * Returns the center position of the in anchor.
   *
   * @method _getInAnchorPosition
   * @returns {Object} An object {x, y}.
   * @protected
   */
  p._getInAnchorPosition = function() {
    return {
      x: this.x-this._width/2-this._settings.get('anchor_offset_x'),
      y: this.y-this._height/2-this._settings.get('anchor_offset_x')
    };
  };

  /**
   * Returns the center position of the out anchor.
   *
   * @method _getOutAnchorPosition
   * @returns {Object} An object {x, y}.
   * @protected
   */
  p._getOutAnchorPosition = function() {
    return {
      x: this.x+this._width/2+this._settings.get('anchor_offset_x'),
      y: this.y+this._height/2+this._settings.get('anchor_offset_x')
    };
  };

  /**
   * Select a block, adding a shadow effect to it.
   *
   * @method _select
   * @protected
   */
  p._select = function() {
    this._isSelected = true;
    this._displayShape.shadow = this._displayShadow;
  };

  /**
   * Deselect a block, removing the shadow effect.
   *
   * @method _deselect
   * @protected
   */
  p._deselect = function() {
    this._isSelected = false;
    this._displayShape.shadow = null;
  };

  p._collapse = function() {};
  p._expand = function() {};

  /**
   * Verifies if the position (x, y) hits any part of the block. This is 
   * equivalent to:
   *
   *     block._hitBody(x, y) || block._hitInAnchor(x, y) || block._hitOutAnchor(x, y)
   *
   * @method _hitTest
   * @param {Integer} x The x position.
   * @param {Integer} y The y position.
   * @returns {Boolean} Whether hit the block or not.
   * @protected
   */
  p._hitTest = function(x, y) {
    return this._displayShape.hitTest(x-this.x, y-this.y);
  };

  /**
   * Verifies if the position (x, y) hits the body of the block.
   * 
   * @method _hitBody
   * @param {Integer} x The x position.
   * @param {Integer} y The y position.
   * @returns {Boolean} Whether hit the block's body or not.
   * @protected
   */
  p._hitBody = function(x, y) {
    if (this._settings.get('layout') === 'horizontal') {
      return (Math.abs(x-this.x) < this._width/2);
    }
    return (Math.abs(y-this.y) < this._height/2);
  };

  /**
   * Verifies if the position (x, y) hits the in anchor of the block.
   * 
   * @method _hitInAnchor
   * @param {Integer} x The x position.
   * @param {Integer} y The y position.
   * @returns {Boolean} Whether hit the in anchor or not.
   * @protected
   */
  p._hitInAnchor = function(x, y) {
    if (this._settings.get('layout') === 'horizontal') {
      var dx = x-this.x;
      return (Math.abs(dx) > this._width/2 && dx < 0);
    }
    var dy = y-this.y;
    return (Math.abs(dy) > this._height/2 && dy < 0);
  };

  /**
   * Verifies if the position (x, y) hits the out anchor of the block.
   * 
   * @method _hitInAnchor
   * @param {Integer} x The x position.
   * @param {Integer} y The y position.
   * @returns {Boolean} Whether hit the out anchor or not.
   * @protected
   */
  p._hitOutAnchor = function(x, y) {
    if (this._settings.get('layout') === 'horizontal') {
      var dx = x-this.x;
      return (Math.abs(dx) > this._width/2 && dx > 0);
    }
    var dy = y-this.y;
    return (Math.abs(dy) > this._height/2 && dy > 0);
  };

  /**
   * Verifies if this block is contained inside a given rectangle.
   * 
   * @method _isContainedIn
   * @param {Integer} x1 The x position.
   * @param {Integer} y1 The y position.
   * @param {Integer} x2 The x+w position.
   * @param {Integer} y2 The y+h position.
   * @returns {Boolean} Whether the block is contained in the rectangle or not.
   * @protected
   */
  p._isContainedIn = function(x1, y1, x2, y2) {
    if (x1 < this.x-this._width/2 &&
        y1 < this.y-this._height/2 &&
        x2 > this.x+this._width/2 &&
        y2 > this.y+this._height/2) {
      return true;
    }

    return false;
  };


  /**
   * Get the compiled title of the block. You can use patterns like `<varname>`
   * in the block title and this method will look through block properties for 
   * the var name. For example.
   *
   *     block.title = 'A <thing> title';
   *     block.properties['thing'] = 'pretty';
   *     block.getTitle() === 'A pretty title';
   * 
   * @method getTitle
   * @returns {String} The compiled title.
   */
  p.getTitle = function() {
    var s = this.title || this.name;
    var this_ = this;
    return s.replace(/(<\w+>)/g, function(match, key) {
      var attr = key.substring(1, key.length-1);
      if (this_.properties.hasOwnProperty(attr))
        return this_.properties[attr];
      else
        return match;
    });
  };

  /**
   * Runs a traversal over the subtree which this block is root.
   *
   *     block.traversal(function(block) {
   *       console.log(block);
   *     })
   * 
   * @method traversal
   * @param {Function} callback The callback called for each block in the 
   *                            subtree. The current block will be passed as 
   *                            argument to the callback.
   * @param {Object} thisarg The object for `this` reference.
   */
  p.traversal = function(callback, thisarg) {
    var blocks = [this];
    while (blocks.length > 0) {
      var block = blocks.pop();
      if (callback.call(thisarg, block) === false) return;

      for (var i=block._outConnections.length-1; i>=0; i--) {
        var c = block._outConnections[i];
        if (c._outBlock) blocks.push(c._outBlock);
      }
    }
  };

  b3e.Block = createjs.promote(Block, 'Container');
})();
/** @module b3e */

(function() {
  'use strict';

  /**
   * Represents a command for the history manager. Each command must have an 
   * undo and a redo specification. The specification must have the following
   * format:
   *
   *     var spec = [thisarg, methodOrFunction, params]
   *
   * For example:
   *
   *     var undo = [this, this.add, [block]];
   *     var redo = [this, this.remove, [block]];
   *     var command = new b3e.Command(undo, redo);
   *
   * @class Command
   * @param {Array} undo The undo specification.
   * @param {Array} redo The redo specification.
   * @constructor
   */
  b3e.Command = function(undo, redo) {

    if (undo.length !== 3) throw 'Invalid undo command, must have [target, method, args]';
    if (redo.length !== 3) throw 'Invalid redo command, must have [target, method, args]';

    function execute(target, method, args) {
      method.apply(target, args);
    }

    /**
     * The tree that is selected in the moment of command is added to the 
     * history manager. This is set by the manager.
     * 
     * @property {b3e.tree.Tree} context;
     */
    this.context = null;

    /**
     * Execute the redo command.
     *
     * @method redo
     */
    this.redo = function() {
      execute(redo[0], redo[1], redo[2]);
    };

    /**
     * Execute the undo command.
     *
     * @method undo
     */
    this.undo = function() {
      execute(undo[0], undo[1], undo[2]);
    };
  };

  /**
   * A list of commands created by the history manager.
   *
   * @class Command
   * @param {Array} undo The undo specification.
   * @param {Array} redo The redo specification.
   * @constructor
   */
  b3e.Commands = function(commands) {

    /**
     * The tree that is selected in the moment of command is added to the 
     * history manager. This is set by the manager.
     * 
     * @property {b3e.tree.Tree} context;
     */
    this.context = null;

    /**
     * Execute the redo command.
     *
     * @method redo
     */
    this.redo = function() {
      for (var i=0; i<commands.length; i++) {
        commands[i].redo();
      }
    };
    
    /**
     * Execute the undo command.
     *
     * @method undo
     */
    this.undo = function() {
      for (var i=commands.length-1; i>=0; i--) {
        commands[i].undo();
      }
    };
  };
})();
/** @module b3e */

(function () {
  "use strict";

  /**
   * Represents a connection between two blocks.
   *
   * @class Connection
   * @constructor
   */
  var Connection = function() {
    this.Shape_constructor();

    this._settings = null;
    this._inBlock = null;
    this._outBlock = null;
  };
  var p = createjs.extend(Connection, createjs.Shape);
 
  /**
   * Apply the editor settings to this connection.
   *
   * @method _applySettings
   * @param Object {b3e.SettingsManager} The settings object.
   * @protected
   */
  p._applySettings = function(settings) {
    this._settings = settings;
    this._redraw();
  };

  /**
   * Redraw the connection.
   *
   * @method _redraw
   * @protected
   */
  p._redraw = function(x1, y1, x2, y2) {
    if (! ((this._inBlock||x1||y1) && (this._outBlock||x2||y2)) ) {
      return;
    }

    var s          = this._settings;
    var graphics   = this.graphics;
    var width      = s.get('connection_width');
    var color      = s.get('connection_color');
    var diff       = s.get('anchor_radius') + s.get('anchor_border_width');
    var arrowWidth = s.get('anchor_radius')/2;
    var layout     = s.get('layout');

    var dx=0; var dy=0; var angle=0; var ax=0; var ay=0;
    // var inAnchor = this._outBlock._getInAnchorPosition();
    // var outAnchor = this._inBlock._getOutAnchorPosition();

    if (!(x1 === 0||x1)) {
      var outAnchor = this._inBlock._getOutAnchorPosition();
      if (layout === 'horizontal') {
        x1 = outAnchor.x;
        y1 = this._inBlock.y;
      } else {
        x1 = this._inBlock.x;
        y1 = outAnchor.y;
      }
    }

    if (!(x2 === 0||x2)) {
      var inAnchor = this._outBlock._getInAnchorPosition();
      if (layout === 'horizontal') {
        x2 = inAnchor.x - diff;
        y2 = this._outBlock.y;
      } else {
        x2 = this._outBlock.x;
        y2 = inAnchor.y - diff;
      }
    }

    if (layout === 'horizontal') {
      dx = 2.5*(x2 - x1)/4;
      ax = -arrowWidth;
    } else {
      dy = 2.5*(y2 - y1)/4;
      ay = -arrowWidth;
      angle = 90;
    }

    graphics.clear();
    graphics.setStrokeStyle(width, 'round');
    graphics.beginStroke(color);
    graphics.moveTo(x1, y1);
    graphics.bezierCurveTo(x1+dx, y1+dy, x2-dx, y2-dy, x2, y2);
    graphics.beginFill(color);
    graphics.drawPolyStar(x2+ax, y2+ay, arrowWidth, 3, 0, angle);
    graphics.endFill();
    graphics.endStroke();
  };

  b3e.Connection = createjs.promote(Connection, 'Shape');
})();

/**
 * Polyfill and util functions.
 */

/**
 * JSON
 */
if (!JSON3) {
  JSON3 = JSON;
}

/**
 * String.format function
 */
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) { 
      return typeof args[number] != 'undefined'?
        args[number] : match
      ;
    });
  };
}

/**
 * Remove function
 */
if (!Array.prototype.remove) {
  Array.prototype.remove = function() {
    var what, a = arguments, L = a.length, ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
  };
}

/**
 * Array.forEach function
 * 
 * Production steps of ECMA-262, Edition 5, 15.4.4.18
 * Reference: http://es5.github.io/#x15.4.4.18
 */
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this === null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

/**
 * Object.keys function
 * From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
 */
if (!Object.keys) {
  Object.keys = (function() {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function(obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}
/** @module b3e */
(function() {
  'use strict';

  /**
   * A node specification.
   *
   * @class Node
   * @param {Boolean} isDefault Whether the node is provided by default or not.
   * @constructor
   */
  b3e.Node = function(isDefault) {
    this.spec = null;
    this.name = null;
    this.title = null;
    this.category = null;
    this.description = null;
    this.properties = {};
    this.isDefault = !!isDefault;

    /**
     * Copy this node.
     *
     * @method copy
     * @returns {b3e.Node} A copy of this node
     */
    this.copy = function() {
      var n         = new b3e.Node(this.isDefault);
      n.spec        = this.spec;
      n.name        = this.name;
      n.title       = this.title;
      n.category    = this.category;
      n.description = this.description;
      n.properties  = this.properties;
      
      return n;
    };
  };
})();
/**
 * Root node specification.
 */
b3e.Root = {
  name     : 'Root',
  category : 'root',
  title    : 'A behavior tree'
};
(function () {
  "use strict";

  /**
   * A selecion box in the screen.
   *
   * @class SelectionBox
   * @constructor
   */
  var SelectionBox = function() {
    this.Shape_constructor();

    this._settings = null;
    this.alpha = 0.3;
    this.visible = false;
  };
  var p = createjs.extend(SelectionBox, createjs.Shape);

  /**
   * Apply the editor settings to the selection box.
   *
   * @method _applySettings
   * @param Object {b3e.SettingsManager} The settings object.
   * @protected
   */
  p._applySettings = function(settings) {
    this._settings = settings;
    this._redraw();
  };

  /**
   * Redraw the box.
   *
   * @method _redraw
   * @protected
   */
  p._redraw = function(x1, y1, x2, y2) {
    var color = this._settings.get('selection_color');
    var graphics = this.graphics;

    var x = Math.min(x1, x2);
    var y = Math.min(y1, y2);
    var w = Math.abs(x1 -x2);
    var h = Math.abs(y1 -y2);

    graphics.clear();
    graphics.beginFill(color);
    graphics.drawRect(x, y, w, h);
    graphics.endFill();
  };

  b3e.SelectionBox = createjs.promote(SelectionBox, 'Shape');
})();
/**
 * Default settings of the editor.
 *
 * @constant {Object} DEFAULT_SETTINGS
 * @memberOf b3e
 */

(function () {
  "use strict";

  var DEFAULT_SETTINGS = {
    // CAMERA
    zoom_initial : 1.0,
    zoom_min     : 0.25,
    zoom_max     : 2.0,
    zoom_step    : 0.25,
    
    // EDITOR
    snap_x        : 12,
    snap_y        : 12,
    snap_offset_x : 0,
    snap_offset_y : 0,
    layout        : 'horizontal', // vertical
    max_history   : 100,

    // COLORS
    background_color        : '#171717',
    selection_color         : '#4BB2FD',
    block_border_color      : '#6D6D6D',
    block_symbol_color      : '#333333',
    anchor_background_color : '#EFEFEF',

    connection_color        : '#6D6D6D',
    root_color              : '#FFFFFF',
    decorator_color         : '#FFFFFF',
    composite_color         : '#FFFFFF',
    tree_color              : '#FFFFFF',
    action_color            : '#FFFFFF',
    condition_color         : '#FFFFFF',

    // CONNECTION
    connection_width       : 2,
    
    // ANCHOR
    anchor_border_width    : 2,
    anchor_radius          : 7,
    anchor_offset_x        : 4,
    anchor_offset_y        : 0,
    
    // BLOCK
    block_border_width     : 2,
    block_root_width       : 40,
    block_root_height      : 40,
    block_tree_width       : 160,
    block_tree_height      : 40,
    block_composite_width  : 40,
    block_composite_height : 40,
    block_decorator_width  : 60,
    block_decorator_height : 60,
    block_action_width     : 160,
    block_action_height    : 40,
    block_condition_width  : 160,
    block_condition_height : 40,
  };

  b3e.DEFAULT_SETTINGS = DEFAULT_SETTINGS;
})();
/** @module b3e */

(function () {
  "use strict";

  /**
   * The settings manager handle the editor settings.
   *
   * @class SettingsManager
   * @constructor
   */
  var SettingsManager = function() {
    this._dict = {};
  };
  var p = SettingsManager.prototype;
  
  /**
   * Erases all current settings.
   * 
   * @method clear
   */
  p.clear = function() {
    this._dict = {};
  };

  /**
   * Stores a value into the settings.
   * 
   * @method set
   * @param {String} key The unique identifier.
   * @param {Object} value The value.
   */
  p.set = function(key, value) {
    this._dict[key] = value;
  };

  /**
   * Retrieves a value from the settings.
   * 
   * @method get
   * @param {String} key The unique identifier.
   * @return {Object} The value.
   */
  p.get = function(key) {
    return this._dict[key];
  };

  /**
   * Stores a set of values into the settings.
   * 
   * @method load
   * @param {String} data An object containing pairs of `key, values`.
   */
  p.load = function(data) {
    for (var key in data) {
      this.set(key, data[key]);
    }
  };
 
  b3e.SettingsManager = SettingsManager;
})();
(function() {
  "use strict";

  var makeAnchor = function(shape, x, y, radius, bg_color, border_width, border_color) {
    shape.graphics.beginFill(bg_color);
    shape.graphics.setStrokeStyle(border_width, 'round');
    shape.graphics.beginStroke(border_color);
    shape.graphics.drawCircle(x, y, radius);
    shape.graphics.endStroke();
    shape.graphics.endFill();
  };

  var makeRect = function(shape, w, h, radius, bg_color, border_width, border_color) {
    shape.graphics.beginFill(bg_color);
    shape.graphics.setStrokeStyle(border_width, 'round');
    shape.graphics.beginStroke(border_color);
    shape.graphics.drawRoundRect(-w/2, -h/2, w, h, radius);
    shape.graphics.endStroke();
    shape.graphics.endFill();
  };

  var makeTree = function(shape, w, h, radius, bg_color, border_width, border_color) {
    shape.graphics.beginFill(bg_color);
    shape.graphics.setStrokeStyle(border_width, 'round');
    shape.graphics.beginStroke(border_color);
    shape.graphics.moveTo(-w/2, 0);
    shape.graphics.lineTo(-w/2+10, -h/2);
    shape.graphics.lineTo(w/2-10, -h/2);
    shape.graphics.lineTo(w/2, 0);
    shape.graphics.lineTo(w/2-10, h/2);
    shape.graphics.lineTo(-w/2+10, h/2);
    shape.graphics.lineTo(-w/2, 0);
    shape.graphics.endStroke();
    shape.graphics.endFill();
  };

  var makeEllipse = function(shape, w, h, bg_color, border_width, border_color) {
    shape.graphics.beginFill(bg_color);
    shape.graphics.setStrokeStyle(border_width, 'round');
    shape.graphics.beginStroke(border_color);
    shape.graphics.drawEllipse(-w/2, -h/2, w, h);
    shape.graphics.endStroke();
    shape.graphics.endFill();
  };

  var makeRhombus = function(shape, w, h, bg_color, border_width, border_color) {
    shape.graphics.beginFill(bg_color);
    shape.graphics.setStrokeStyle(border_width, 'round');
    shape.graphics.beginStroke(border_color);
    shape.graphics.moveTo(0, h/2);
    shape.graphics.lineTo(w/2, 0);
    shape.graphics.lineTo(0, -h/2);
    shape.graphics.lineTo(-w/2, 0);
    shape.graphics.lineTo(0, h/2);
    shape.graphics.endStroke();
    shape.graphics.endFill();
  };

  b3e.draw.rootShape = function(block, settings) {
    var w = block._width;
    var h = block._height;
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;

    var x = 0;
    var y = 0;
    if (settings.get('layout') === 'horizontal') {
      x = w/2+anchorOffsetX;
    } else {
      y = h/2+anchorOffsetX;
    }

    makeAnchor(shape, x, y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeRect(shape, w, h, 15,
        settings.get('root_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.compositeShape = function(block, settings) {
    var bounds = block._displaySymbol.getBounds();
    var _width = 0;

    if (bounds) { _width = bounds.width+20; }

    var w = Math.max(_width, block._width);
    var h = block._height;
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;
    block._width = w;
    block._height = h;

    var x = 0;
    var y = 0;
    if (settings.get('layout') === 'horizontal') {
      x = w/2+anchorOffsetX;
    } else {
      y = h/2+anchorOffsetX;
    }
    makeAnchor(shape, x, y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeAnchor(shape, -x, -y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeRect(shape, w, h, 15,
        settings.get('composite_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.decoratorShape = function(block, settings) {
    var bounds = block._displaySymbol.getBounds();

    var w = Math.max(bounds.width+40, block._width);
    var h = Math.max(bounds.height+50, block._height);
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;
    block._width = w;
    block._height = h;

    var x = 0;
    var y = 0;
    if (settings.get('layout') === 'horizontal') {
      x = w/2+anchorOffsetX;
    } else {
      y = h/2+anchorOffsetX;
    }
    makeAnchor(shape, x, y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeAnchor(shape, -x, -y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    
    makeRhombus(shape, w, h,
        settings.get('decorator_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.actionShape = function(block, settings) {

    var bounds = block._displaySymbol.getBounds();
    var w = Math.max(bounds.width+15, block._width);
    var h = Math.max(bounds.height+15, block._height);
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;
    block._width = w;
    block._height = h;

    var x = 0;
    var y = 0;
    if (settings.get('layout') === 'horizontal') {
      x = w/2+anchorOffsetX;
    } else {
      y = h/2+anchorOffsetX;
    }
    makeAnchor(shape, -x, -y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeRect(shape, w, h, 15,
        settings.get('action_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.conditionShape = function(block, settings) {
    var bounds = block._displaySymbol.getBounds();

    var w = Math.max(bounds.width+15, block._width);
    var h = Math.max(bounds.height+15, block._height);
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;
    block._width = w;
    block._height = h;

    makeAnchor(shape, -w/2-anchorOffsetX, 0, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeEllipse(shape, w, h, 
        settings.get('condition_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.treeShape = function(block, settings) {
    var bounds = block._displaySymbol.getBounds();
    var w = Math.max(bounds.width+15, block._width);
    var h = Math.max(bounds.height+15, block._height);
    var anchorOffsetX = settings.get('anchor_offset_x');
    var shape = block._displayShape;
    block._width = w;
    block._height = h;

    var x = 0;
    var y = 0;
    if (settings.get('layout') === 'horizontal') {
      x = w/2+anchorOffsetX;
    } else {
      y = h/2+anchorOffsetX;
    }
    makeAnchor(shape, -x, -y, 
        settings.get('anchor_radius'),
        settings.get('anchor_background_color'),
        settings.get('anchor_border_width'),
        settings.get('block_border_color')
    );
    makeTree(shape, w, h, 15,
        settings.get('tree_color'),
        settings.get('block_border_width'),
        settings.get('block_border_color')
    );
    return shape;
  };

  b3e.draw.SHAPES = {
    'root'      : b3e.draw.rootShape,
    'tree'      : b3e.draw.treeShape,
    'composite' : b3e.draw.compositeShape,
    'decorator' : b3e.draw.decoratorShape,
    'action'    : b3e.draw.actionShape,
    'condition' : b3e.draw.conditionShape,
  };

}());

(function() {
  "use strict";

  b3e.draw.rootSymbol = function(block, settings) {
    // var shape = block.displayObject;
    var shape = new createjs.Shape();

    var w = block._width;
    var h = block._height;
    var swidth = h/20;
    var ssize = h/5;
    var scolor = settings.get('block_symbol_color');

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.drawCircle(0, 0, ssize);
    shape.graphics.moveTo(-ssize, ssize);
    shape.graphics.lineTo(ssize, -ssize);
    shape.graphics.endStroke();

    return shape;
  };

  b3e.draw.sequenceSymbol = function(block, settings) {
    // var shape = block.displayObject;
    // var shape = block._shapeObject;
    var shape = new createjs.Shape();

    var w = block._width;
    var h = block._height;
    var swidth = h/20;
    var ssize = h/4;
    var scolor = settings.get('block_symbol_color');

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.beginFill(scolor);
    shape.graphics.moveTo(-ssize, 0);
    shape.graphics.lineTo(ssize, 0);
    shape.graphics.drawPolyStar(ssize/2, 0, ssize/2, 3, 0, 0);
    shape.graphics.endFill();
    shape.graphics.endStroke();

    return shape;
  };

  b3e.draw.memsequenceSymbol = function(block, settings) {
    var shape = new createjs.Shape();

    var w = block._width;
    var h = block._height;
    var swidth = h/20;
    var ssize = h/4;
    var scolor = settings.get('block_symbol_color');

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.beginFill(scolor);
    shape.graphics.drawPolyStar(0, -ssize*0.75, ssize/2, 6, ssize/10, 0);

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.beginFill(scolor);
    shape.graphics.moveTo(-ssize, ssize/2);
    shape.graphics.lineTo(ssize, ssize/2);
    shape.graphics.drawPolyStar(ssize/2, ssize/2, ssize/2, 3, 0, 0);
    shape.graphics.endFill();
    shape.graphics.endStroke();

    return shape;
  };

  b3e.draw.prioritySymbol = function(block, settings) {
    // var shape = block.displayObject;
    // var shape = block._shapeObject;
    var shape = new createjs.Shape();

    var w = block._width;
    var h = block._height;
    var swidth = h/20;
    var ssize = h/8;
    var scolor = settings.get('block_symbol_color');

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.arc(0, -ssize, ssize, 3.141561, 1.570796, false);
    shape.graphics.lineTo(0, ssize);
    shape.graphics.beginFill(scolor);
    shape.graphics.drawCircle(0, ssize*2, swidth/2);

    shape.graphics.endFill();
    shape.graphics.endStroke();

    return shape;
  };

  b3e.draw.memprioritySymbol = function(block, settings) {
    var shape = new createjs.Shape();

    var w = block._width;
    var h = block._height;
    var swidth = h/20;
    var ssize = h/8;
    var scolor = settings.get('block_symbol_color');

    shape.graphics.setStrokeStyle(swidth, 'round');
    shape.graphics.beginStroke(scolor);
    shape.graphics.arc(-ssize, -ssize, ssize, 3.141561, 1.570796, false);
    shape.graphics.lineTo(-ssize, ssize);
    shape.graphics.beginFill(scolor);
    shape.graphics.drawCircle(-ssize, ssize*2, swidth/2);
    shape.graphics.drawPolyStar(ssize*1.5, 0, ssize/2, 6, ssize/10, 0);

    shape.graphics.endFill();
    shape.graphics.endStroke();

    return shape;
  };

  b3e.draw.textSymbol = function(block, settings) {
    var text = new createjs.Text(
        block.getTitle(),
        '18px Arial',
        settings.get('block_symbol_color')
    );
    text.textAlign = 'center';

    var bounds = text.getBounds();
    text.regY = bounds.height/2;

    // text.x = -block._width/2;
    // text.y = -block._height/2;

    return text;
  };


  b3e.draw.SYMBOLS = {
    'Root'        : b3e.draw.rootSymbol,
    'Sequence'    : b3e.draw.sequenceSymbol,
    'Priority'    : b3e.draw.prioritySymbol,
    'MemSequence' : b3e.draw.memsequenceSymbol,
    'MemPriority' : b3e.draw.memprioritySymbol,
  };

}());

(function () {
  "use strict";

  /**
   * Editor main class.
   */
  var Editor = function() {
    this.Container_constructor();

    // Variables
    this._project = null;
    this._game = null;
    this._settings = new b3e.SettingsManager();
    this._dirty = 0;

    // Systems
    this._systems = [];

    // Managers
    this.project = null;
    this.export = null;
    this.import = null;
    this.shortcuts = null;

    this._createGame();
  };
  var p = createjs.extend(Editor, createjs.Container);
  
  p._createGame = function() {
    var self = this;
    this._game = new tine.Game(null, {
      update : function() { self._update(); },
    });

    this._initialize();
  };

  /**
   * Initializes DOM, DOM events, managers and display objects.
   */
  p._initialize = function() {
    var self = this;

    // RESIZE
    var resize = function() {
      self._game.canvas.width = window.innerWidth;
      self._game.canvas.height = window.innerHeight;
    };
    window.onresize = resize;
    resize();

    // GAME
    this._game.stage.addChild(this);

    // MANAGERS
    this.project = new b3e.editor.ProjectManager(this);
    this.export = new b3e.editor.ExportManager(this);
    this.import = new b3e.editor.ImportManager(this);
    this.shortcuts = new b3e.editor.ShortcutManager(this);
    
    // SYSTEMS
    this._systems.push(new b3e.editor.CameraSystem(this));
    this._systems.push(new b3e.editor.ConnectionSystem(this));
    this._systems.push(new b3e.editor.SelectionSystem(this));
    this._systems.push(new b3e.editor.DragSystem(this));
    this._systems.push(new b3e.editor.CollapseSystem(this));
    this._systems.push(new b3e.editor.ShortcutSystem(this));
    
    // SETTINGS
    this.applySettings('default');
  };

  /**
   * Called by creatine game.
   */
  p._update = function() {
    var delta = this._game.time.delta;
    this._systems.forEach(function(system) {
      system.update(delta);
    });
  };

  p.trigger = function(name, target, variables) {
    variables = variables || {};

    var event = new createjs.Event(name);
    event._target = target;
    event._data = variables;
    this.dispatchEvent(event);
  };

  p.applySettings = function(settings) {
    if (settings === 'default') {
      settings = b3e.DEFAULT_SETTINGS;
      this._settings.clear();
    }

    if (settings) {
      this._settings.load(settings);
    }

    var canvas = this._game.canvas;
    canvas.style.backgroundColor = this._settings.get('background_color');

    this.project._applySettings(this._settings);
    this.export._applySettings(this._settings);
    this.import._applySettings(this._settings);
    this.shortcuts._applySettings(this._settings);
  };

  p.preview = function(name) {
    var canvas = document.createElement('canvas');

    var p = this.project.get();
    var node = p.nodes.get(name);
    var tree = p.trees.getSelected();

    if (!node) return;
    var block = new b3e.Block(node);
    block._applySettings(this._settings);
    block.x = block._width;
    block.y = block._height;

    canvas.setAttribute('width', block._width*tree.scaleX*2);
    canvas.setAttribute('height', block._height*tree.scaleY*2);

    var stage = new createjs.Stage(canvas);
    stage.scaleX = tree.scaleX;
    stage.scaleY = tree.scaleY;
    stage.addChild(block);
    stage.update();

    return canvas;
  };

  p.isDirty = function() {
    return this._dirty !== 0;
  };

  p.clearDirty = function() {
    this._dirty = 0;
  };

  b3e.editor.Editor = createjs.promote(Editor, 'Container');
})();
(function () {
  "use strict";

  var Project = function(editor) {
    this.Container_constructor();

    // Variables
    this._id = b3.createUUID();
    this._editor = editor;
    this._selectedTree = null;
    this._clipboard = null;
    this._nodes = {};

    // Managers
    this.trees = null;
    this.nodes = null;
    this.history = null;

    this._initialize();
  };
  var p = createjs.extend(Project, createjs.Container);

  p._initialize = function() {
    this.trees = new b3e.project.TreeManager(this._editor, this);
    this.nodes = new b3e.project.NodeManager(this._editor, this);
    this.history = new b3e.project.HistoryManager(this._editor, this);

    this.nodes.add(b3e.Root, true);
    this.nodes.add(b3.Sequence, true);
    this.nodes.add(b3.Priority, true);
    this.nodes.add(b3.MemSequence, true);
    this.nodes.add(b3.MemPriority, true);
    this.nodes.add(b3.Repeater, true);
    this.nodes.add(b3.RepeatUntilFailure, true);
    this.nodes.add(b3.RepeatUntilSuccess, true);
    this.nodes.add(b3.MaxTime, true);
    this.nodes.add(b3.Inverter, true);
    this.nodes.add(b3.Limiter, true);
    this.nodes.add(b3.Failer, true);
    this.nodes.add(b3.Succeeder, true);
    this.nodes.add(b3.Runner, true);
    this.nodes.add(b3.Error, true);
    this.nodes.add(b3.Wait, true);

    this._applySettings(this._editor._settings);
    this.history.clear();
    this._editor.clearDirty();
  };

  p._applySettings = function(settings) {
    this.trees._applySettings(settings);
    this.nodes._applySettings(settings);
    this.history._applySettings(settings);
  };

  b3e.project.Project = createjs.promote(Project, 'Container');
})();
(function () {
  "use strict";

  var Tree = function(editor, project) {
    this.Container_constructor();

    // Variables
    this._id = b3.createUUID();
    this._editor = editor;
    this._project = project;
    this._selectedBlocks = [];
    this._selectionBox = null;
    this._root = null;

    // Layers
    this._blocks = new createjs.Container();
    this._connections = new createjs.Container();
    this._overlay = new createjs.Container();

    // Managers
    this.blocks = null;
    this.connections = null;
    this.edit = null;
    this.selection = null;
    this.view = null;
    this.organizer = null;

    this._initialize();
  };
  var p = createjs.extend(Tree, createjs.Container);

  p._initialize = function() {
    this.blocks = new b3e.tree.BlockManager(this._editor, this._project, this);
    this.connections = new b3e.tree.ConnectionManager(this._editor, this._project, this);
    this.edit = new b3e.tree.EditManager(this._editor, this._project, this);
    this.selection = new b3e.tree.SelectionManager(this._editor, this._project, this);
    this.view = new b3e.tree.ViewManager(this._editor, this._project, this);
    this.organize = new b3e.tree.OrganizeManager(this._editor, this._project, this);

    this.addChild(this._connections);
    this.addChild(this._blocks);
    this.addChild(this._overlay);

    this._selectionBox = new b3e.SelectionBox();
    this._overlay.addChild(this._selectionBox);

    this._root = this.blocks.add('Root', 0, 0);
    this._applySettings(this._editor._settings);

    this.view.center();
  };

  p._applySettings = function(settings) {
    this._selectionBox._applySettings(settings);

    this.blocks._applySettings(settings);
    this.connections._applySettings(settings);
    this.edit._applySettings(settings);
    this.selection._applySettings(settings);
    this.view._applySettings(settings);
    this.organize._applySettings(settings);
  };

  b3e.tree.Tree = createjs.promote(Tree, 'Container');
})();
b3e.editor.ExportManager = function(editor) {
  "use strict";

  function getBlockChildrenIds(block) {
    var conns = block._outConnections.slice(0);
    if (editor._settings.get('layout') === 'horizontal') {
      conns.sort(function(a, b) {
        return a._outBlock.y - 
               b._outBlock.y;
      });
    } else {
      conns.sort(function(a, b) {
        return a._outBlock.x - 
               b._outBlock.x;
      });
    }

    var nodes = [];
    for (var i=0; i<conns.length; i++) {
      nodes.push(conns[i]._outBlock.id);
    }

    return nodes;
  }

  this.projectToData = function() {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();

    var data = {
      version      : b3e.VERSION,
      scope        : 'project',
      selectedTree : (tree?tree._id:null),
      trees        : [],
      custom_nodes : this.nodesToData()
    };

    project.trees.each(function(tree) {
      var d = this.treeToData(tree, true);
      d.id = tree._id;
      data.trees.push(d);
    }, this);

    return data;
  };
  
  this.treeToData = function(tree, ignoreNodes) {
    var project = editor.project.get();
    if (!project) return;

    if (!tree) {
      tree = project.trees.getSelected();
    } else {
      tree = project.trees.get(tree);
      if (!tree) return;
    }

    var root = tree.blocks.getRoot();
    var first = getBlockChildrenIds(root);
    var data = {
      version      : b3e.VERSION,
      scope        : 'tree',
      id           : tree._id,
      title        : root.title,
      description  : root.description,
      root         : first[0] || null,
      properties   : root.properties,
      nodes        : {},
      display     : {
        camera_x : tree.x,
        camera_y : tree.y,
        camera_z : tree.scaleX,
        x        : root.x,
        y        : root.y,
      },
    };

    if (!ignoreNodes) {
      data.custom_nodes = this.nodesToData();
    }

    tree.blocks.each(function(block) {
      if (block.category !== 'root') {
        var d ={
          id          : block.id,
          name        : block.name,
          title       : block.title,
          description : block.description,
          properties  : block.properties,
          display     : {x:block.x, y:block.y}
        };

        var children = getBlockChildrenIds(block);
        if (block.category === 'composite') {
          d.children = children;
        } else if (block.category === 'decorator') {
          d.child = children[0];
        }

        data.nodes[block.id] = d;
      }
    });

    return data;
  };

  this.nodesToData = function() {
    var project = editor.project.get();
    if (!project) return;

    var data = [];
    project.nodes.each(function(node) {
      if (!node.isDefault) {
        data.push({
          version     : b3e.VERSION,
          scope       : 'node',
          name        : node.name,
          category    : node.category,
          title       : node.title,
          description : node.description,
          properties  : node.properties,
        });
      }
    });

    return data;
  };

  this.nodesToJavascript = function() {};

  this._applySettings = function(settings) {};
};
b3e.editor.ImportManager = function(editor) {
  "use strict";

  this.projectAsData = function(data) {
    var project = editor.project.get();
    if (!project) return;

    if (data.custom_nodes) this.nodesAsData(data.custom_nodes);
    if (data.trees) this.treesAsData(data.trees);
    if (data.selectedTree) {
      project.trees.select(data.selectedTree);
    }
    editor.trigger('projectimported');
  };

  this.treeAsData = function(data) {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.add(data.id);
    var root = tree.blocks.getRoot();
    var first = null;

    // Tree data
    var display      = data.display||{};
    tree.x           = display.camera_x || 0;
    tree.y           = display.camera_y || 0;
    tree.scaleX      = display.camera_z || 1;
    tree.scaleY      = display.camera_z || 1;
    var treeNode = project.nodes.get(tree._id);
    treeNode.title = data.title;

    root.title       = data.title;
    root.description = data.description;
    root.properties  = data.properties;
    root.x           = display.x || 0;
    root.y           = display.y || 0;

    // Custom nodes
    if (data.custom_nodes) this.nodesAsData(data.custom_nodes);

    var id, spec;

    // Add blocks
    for (id in data.nodes) {
      spec = data.nodes[id];
      var block = null;
      display = spec.display || {};

      block = tree.blocks.add(spec.name, spec.display.x, spec.display.y);
      block.id = spec.id;
      block.title = spec.title;
      block.description = spec.description;
      block.properties = tine.merge({}, block.properties, spec.properties);
      block._redraw();
      
      if (spec.id === data.root) {
        first = block;
      }
    }

    // Add connections
    for (id in data.nodes) {
      spec = data.nodes[id];
      var inBlock = tree.blocks.get(id);

      var children = null;
      if (inBlock.category === 'composite' && spec.children) {
        children = spec.children;
      }
      else if (spec.child && (inBlock.category == 'decorator' ||
                              inBlock.category == 'root')) {
        children = [spec.child];
      }
      
      if (children) {
        for (var i=0; i<children.length; i++) {
          var outBlock = tree.blocks.get(children[i]);
          tree.connections.add(inBlock, outBlock);
        }
      }
    }

    // Finish
    if (first) {
      tree.connections.add(root, first);
    }

    if (!data.display) {
      tree.organize.organize(true);
    }

    tree.selection.deselectAll();
    tree.selection.select(root);
    project.history.clear();

    editor.trigger('treeimported');
  };

  this.treesAsData = function(data) {
    for (var i=0; i<data.length; i++) {
      this.treeAsData(data[i]);
    }
  };

  this.nodesAsData = function(data) {
    var project = editor.project.get();
    if (!project) return;

    for (var i=0; i<data.length; i++) {
      var template = data[i];
      project.nodes.add(template);
    }
    editor.trigger('nodeimported');
  };
  this._applySettings = function(settings) {};
};
b3e.editor.ProjectManager = function(editor) {
  "use strict";

  /**
   * Creates a new project.
   */
  this.create = function() {
    this.close();

    var project = new b3e.project.Project(editor);
    editor.addChild(project);
    editor._project = project;
    editor.trigger('projectcreated', editor._project);
    
    editor._project.trees.add();
  };

  /**
   * Loads a project from data.
   */
  this.open = function(data) {
    this.close();

    var project = new b3e.project.Project(editor);
    editor.addChild(project);
    editor._project = project;
    
    editor.import.projectAsData(data);
    editor.trigger('projectopened', editor._project);
    editor.clearDirty();
  };

  /**
   * Exit the current project.
   */
  this.close = function() {
    var project = editor._project;
    if (project) {
      editor.removeChild(project);
      editor.trigger('projectclosed', project);
    }
  };

  /**
   * Gets the current project. Returns `null` if none.
   */
  this.get = function() {
    return editor._project;
  };


  this._applySettings = function(settings) {
    if (editor._project) {
      editor._project._applySettings(settings);
    }
  };
};
b3e.editor.ShortcutManager = function(editor) {
  "use strict";

  this._applySettings = function(settings) {};
};
b3e.editor.CameraSystem = function(editor) {
  "use strict";

  var isDragging = false;
  var offsetX = 0;
  var offsetY = 0;

  this.update = function(delta) {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var kb = editor._game.keyboard;
    var k = tine.keys;

    if (kb.isDown(k.CTRL)) {
      if (kb.isPressed(k.UP)) {
        tree.view.zoomIn();
      } else if (kb.isPressed(k.DOWN)) {
        tree.view.zoomOut();
      }
    }

    else {
      if (kb.isDown(k.LEFT)) {
        tree.x += delta;
      } else if (kb.isDown(k.RIGHT)) {
        tree.x -= delta;
      }

      if (kb.isDown(k.UP)) {
        tree.y += delta;
      } else if (kb.isDown(k.DOWN)) {
        tree.y -= delta;
      }
    }
  };

  this.onMouseDown = function(e) {
    if (e.nativeEvent.which !== 2) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    editor._game.canvas.className += " grabbing";

    isDragging = true;
    offsetX = editor._game.mouse.x - tree.x;
    offsetY = editor._game.mouse.y - tree.y;
  };
  this.onMouseMove = function(e) {
    if (!isDragging) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    tree.x = editor._game.mouse.x - offsetX;
    tree.y = editor._game.mouse.y - offsetY;
  };
  this.onMouseUp = function(e) {
    if (e.nativeEvent.which !== 2) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    editor._game.canvas.className = editor._game.canvas.className.replace(/(?:^|\s)grabbing(?!\S)/g, '');

    isDragging = false;
    offsetX = 0;
    offsetY = 0;
  };
  this.onMouseWheel = function(e) {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    if (e.ctrlKey) {
      if ((e.wheelDeltaY||e.deltaY) > 0) {
        tree.view.zoomIn();
      } else {
        tree.view.zoomOut();
      }
    }
  };


  var self = this;
  editor._game.stage.on('stagemousedown', this.onMouseDown, this);
  editor._game.stage.on('stagemousemove', this.onMouseMove, this);
  editor._game.stage.on('stagemouseup', this.onMouseUp, this);
  editor._game.canvas.addEventListener('wheel', function(e) {
    self.onMouseWheel(e);
  }, false);
  editor._game.canvas.addEventListener('mousewheel', function(e) {
    self.onMouseWheel(e);
  }, false);
  editor._game.canvas.addEventListener('DOMMouseScroll ', function(e) {
    self.onMouseWheel(e);
  }, false);
};

b3e.editor.CollapseSystem = function(editor) {
  "use strict";

  this.update = function(delta) {

  };
};

b3e.editor.ConnectionSystem = function(editor) {
  "use strict";

  var connection = null;
  var lastOutBlock = null;

  this.update = function(delta) {};

  this.onMouseDown = function(e) {
    if (e.nativeEvent.which !== 1) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    // if clicked on block
    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;
    var block = tree.blocks.getUnderPoint(x, y);

    if (connection || !block) return;

    if (block._hitOutAnchor(x, y)) {
      // if user clicked at the outAnchor
      connection = tree.connections.add(block, null);

    } else if (block._hitInAnchor(x, y)) {
      // if user clicked at the inAnchor
      var c = block._inConnection;
      if (!c)
          return;

      block._inConnection = null;
      c._outBlock = null;
      lastOutBlock = block;

      connection = c;
    }
  };

  this.onMouseMove = function(e) {
    // if no connection, return
    if (!connection) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;

    // redraw
    connection._redraw(null, null, x, y);
  };

  this.onMouseUp = function(e) {
    if (e.nativeEvent.which !== 1) return;

    // if no connection, return
    if (!connection) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;


    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;
    var block = tree.blocks.getUnderPoint(x, y);

    // if not connection or connection but no block
    project.history._beginBatch();
    if (!block || block === connection._inBlock || block.category === 'root') {
      if (lastOutBlock) {
        // Add again to connection in order to create history 
        lastOutBlock._inConnection = connection;
        connection._outBlock = lastOutBlock;
      }
      tree.connections.remove(connection);
    } else {
      var c;

      // if double parent on node
      if (block._inConnection) {

        c = block._inConnection;
        tree.connections.remove(c);
      }

      // if double children on root
      if ((connection._inBlock.category === 'root' ||
           connection._inBlock.category === 'decorator') &&
           connection._inBlock._outConnections.length > 1) {

        c = connection._inBlock._outConnections[0];
        tree.connections.remove(c);
      }

      connection._outBlock = block;
      block._inConnection = connection;

      var _old = [tree.connections, tree.connections._remove, [block]];
      var _new = [tree.connections, tree.connections.add, [connection._inBlock, block]];
      project.history._add(new b3e.Command(_old, _new));

      connection._redraw();
    }
    project.history._endBatch();

    connection = null;
  };

  editor._game.stage.on('stagemousedown', this.onMouseDown, this);
  editor._game.stage.on('stagemousemove', this.onMouseMove, this);
  editor._game.stage.on('stagemouseup', this.onMouseUp, this);
};

b3e.editor.DragSystem = function(editor) {
  "use strict";

  var isDragging = false;
  var dragX0 = 0;
  var dragY0 = 0;

  this.update = function(delta) {};

  this.onMouseDown = function(e) {
    if (e.nativeEvent.which !== 1 || 
        e.nativeEvent.ctrlKey || 
        isDragging) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;
    var block = tree.blocks.getUnderPoint(x, y);

    // if mouse not on block
    if (!block) return;

    // if no block selected
    if (!block._isSelected) return;

    // if mouse in anchor
    if (!block._hitBody(x, y)) return;

    // start dragging
    isDragging = true;
    dragX0 = x;
    dragY0 = y;

    for (var i=0; i<tree._selectedBlocks.length; i++) {
      block = tree._selectedBlocks[i];
      block._isDragging = true;
      block._dragOffsetX = x - block.x;
      block._dragOffsetY = y - block.y;
    }
  };

  this.onMouseMove = function(e) {
    if (!isDragging) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;

    for (var i=0; i<tree._selectedBlocks.length; i++) {
      var block = tree._selectedBlocks[i];

      var dx = x - block._dragOffsetX;
      var dy = y - block._dragOffsetY;

      block.x = dx;
      block.y = dy;
      block._snap();

      // redraw connections linked to the entity
      if (block._inConnection) {
        block._inConnection._redraw();
      }
      for (var j=0; j<block._outConnections.length; j++) {
        block._outConnections[j]._redraw();
      }
    }
  };

  this.onMouseUp = function(e) {
    if (e.nativeEvent.which !== 1 || !isDragging) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    isDragging = false;
    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;


    project.history._beginBatch();
    for (var i=0; i<tree._selectedBlocks.length; i++) {
      var block = tree._selectedBlocks[i];
      block._isDragging = false;

      var _old = [block, dragX0-block._dragOffsetX, dragY0-block._dragOffsetY];
      var _new = [block, block.x, block.y];

      if (_old[1] === _new[1] && _old[2] === _new[2]) break;

      project.history._add(new b3e.Command(
        [tree.blocks, tree.blocks._move, _old],
        [tree.blocks, tree.blocks._move, _new]
      ));
    }
    project.history._endBatch();
  };

  editor._game.stage.on('stagemousedown', this.onMouseDown, this);
  editor._game.stage.on('stagemousemove', this.onMouseMove, this);
  editor._game.stage.on('stagemouseup', this.onMouseUp, this);
};

b3e.editor.SelectionSystem = function(editor) {
  "use strict";

  var isSelecting = false;
  var ctrl = false;
  var shift = false;
  var alt = false;
  var x0 = 0;
  var y0 = 0;

  this.update = function(delta) {};

  this.onMouseDown = function(e) {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    // mouse left
    if (e.nativeEvent.which !== 1) return;
    ctrl = e.nativeEvent.ctrlKey;
    shift = e.nativeEvent.shiftKey;
    alt = e.nativeEvent.altKey;

    // if clicked on block
    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;
    var block = tree.blocks.getUnderPoint(x, y);

    if (block && block._isSelected && ctrl) {
      if (alt) {
        tree.selection.deselectSubtree(block);
      } else {
        tree.selection.deselect(block);
      }
    }

    else if (block && !block._isSelected && block._hitBody(x, y)) {
      if (!ctrl) tree.selection.deselectAll();
      if (alt) {
        tree.selection.selectSubtree(block);
      } else {
        tree.selection.select(block);
      }
    }
    else if (block && block._hitBody(x, y)) {
      if (alt) {
        tree.selection.selectSubtree(block);
      }
    }

    else if (!block) {
      isSelecting = true;
      x0 = x;
      y0 = y;

      if (!ctrl) tree.selection.deselectAll();
    }
  };

  this.onMouseMove = function(e) {
    if (!isSelecting) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;

    tree._selectionBox.visible = true;
    tree._selectionBox._redraw(x0, y0, x, y);
  };

  this.onMouseUp = function(e) {
    if (e.nativeEvent.which !== 1 || !isSelecting) return;

    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var point = tree.view.getLocalPoint();
    var x = point.x;
    var y = point.y;

    var x1 = Math.min(x0, x);
    var y1 = Math.min(y0, y);
    var x2 = Math.max(x0, x);
    var y2 = Math.max(y0, y);

    tree.blocks.each(function(block) {
      if (block._isContainedIn(x1, y1, x2, y2)) {
        tree.selection.select(block);
      }
    });

    tree._selectionBox.visible = false;
    isSelecting = false;
  };

  editor._game.stage.on('stagemousedown', this.onMouseDown, this);
  editor._game.stage.on('stagemousemove', this.onMouseMove, this);
  editor._game.stage.on('stagemouseup', this.onMouseUp, this);
};

b3e.editor.ShortcutSystem = function(editor) {
  "use strict";

  this.update = function(delta) {
    var project = editor.project.get();
    if (!project) return;

    var tree = project.trees.getSelected();
    if (!tree) return;

    var kb = editor._game.keyboard;
    var k = tine.keys;
  };
};

b3e.project.HistoryManager = function(editor, project) {
  "use strict";

  var queue = [];
  var index = 0;
  var lockRequests = 0;
  var batchRequests = 0;
  var commandBuffer = [];

  this.clear = function() {
    queue = [];
    index = 0;
  };
  this.undo = function() {
    this._lock();
    if (this.canUndo()) {
      index--;
      queue[index].undo();
      project.trees.select(queue[index].context);
    }
    this._unlock();

    editor._dirty--;
  };
  this.redo = function() {
    this._lock();
    if (this.canRedo()) {
      queue[index].redo();
      project.trees.select(queue[index].context);
      index++;
    }
    this._unlock();

    editor._dirty++;
  };
  this.canUndo = function() {
    return index>0;
  };
  this.canRedo = function() {
    return index<queue.length;
  };

  /**
   * Add commands to the historic.
   *
   *     history.add(target, command, args)
   */
  this._add = function(command, merge) {
    if (lockRequests > 0) return;

    // Crear all after index
    if (queue.length > index) {
      queue.splice(index, queue.length-index);
    }

    // Add instruction
    if (batchRequests > 0) {
      commandBuffer.push(command);
    } else {
      index++;
      command.context = project.trees.getSelected();
      queue.push(command);
      
      if (editor._dirty < 0) editor._dirty = 0;
      editor._dirty++;
    }

    // Clear excess
    var max = editor._settings.get('max_history');
    if (queue.length > max) {
      queue.splice(0, 1);
    }
  };

  /**
   * Lock the manager, so it can't receive more commands.
   */
  this._lock = function() {
    // if (lockRequests===0) console.log('------- LOCK -------');
    lockRequests++;
  };
  this._unlock = function() {
    lockRequests--;
    // if (lockRequests===0) console.log('------- UNLOCK -------');
  };

  /**
   * While in batch, merges all added commands to a single command
   */
  this._beginBatch = function() {
    batchRequests++;
  };
  this._endBatch = function() {
    batchRequests = Math.max(0, batchRequests-1);

    if (batchRequests === 0) {
      if (commandBuffer.length > 0) {
        var command = new b3e.Commands(commandBuffer);
        command.context = project.trees.getSelected();
        this._add(command);
      }
      commandBuffer = [];
    }
  };


  this._applySettings = function(settings) {
    var max = settings.get('max_history');
    if (queue.length > max) {
      queue.splice(0, queue.length-max);
    }
  };
};
b3e.project.NodeManager = function(editor, project) {
  "use strict";

  /**
   * Register a node to the node list. You can provide:
   * 
   * - a `b3.BaseNode` instance.
   * - a `b3e.Node` instance.
   * - a generic object containing the node prototype.
   */
  this.add = function(node, isDefault) {
    if (node.prototype) node = node.prototype;

    if (project._nodes[node.name]) {
      return false;
    }

    if (!(node instanceof b3e.Node)) {
      var n         = new b3e.Node(isDefault);
      n.name        = node.name;
      n.category    = node.category;
      n.title       = node.title;
      n.description = node.description;
      n.properties  = tine.merge({}, node.properties||node.parameters);

      node = n;
    }

    project._nodes[node.name] = node;
    if (isDefault !== true) editor.trigger('nodeadded', node);

    var _old = [this, this.remove, [node]];
    var _new = [this, this.add, [node]];
    project.history._add(new b3e.Command(_old, _new));

    return node;
  };

  /**
   * 
   */
  this.get = function(node) {
    if (typeof node !== 'string') return node;
    return project._nodes[node];
  };

  /**
   * 
   */
  this.update = function(node, template) {
    node = this.get(node);
    var oldName = node.name;

    delete project._nodes[node.name];

    if (node.name !== template.name && this.get(template.name)) return false;


    var _oldValues = {
      name        : node.name,
      title       : node.title,
      description : node.description,
      category    : node.category,
      properties  : node.properties,
    };

    if (typeof template.name !== 'undefined') {
      node.name = template.name;
    }
    if (typeof template.title !== 'undefined') {
      node.title = template.title;
    }
    if (typeof template.category !== 'undefined') {
      node.category = template.category;
    }
    if (typeof template.description !== 'undefined') {
      node.description = template.description;
    }
    if (typeof template.properties !== 'undefined') {
      node.properties  = tine.merge({}, template.properties);
    }

    var _newValues = {
      name        : node.name,
      title       : node.title,
      description : node.description,
      category    : node.category,
      properties  : node.properties,
    };

    project.history._beginBatch();

    project.trees.each(function(tree) {
      var blocks = tree.blocks.getAll();
      for (var i=blocks.length-1; i>=0; i--) {
        if (blocks[i].name === oldName) {
          tree.blocks.update(blocks[i]);
        }
      }
    });

    project._nodes[node.name] = node;

    var _old = [this, this.update, [node, _oldValues]];
    var _new = [this, this.update, [node, _newValues]];
    project.history._add(new b3e.Command(_old, _new));
    project.history._endBatch();

    editor.trigger('nodechanged', node);
  };

  /**
   * 
   */
  this.remove = function(node) {
    project.history._beginBatch();

    var name = node.name||node;
    delete project._nodes[name];

    project.trees.each(function(tree) {
      var blocks = tree.blocks.getAll();
      for (var i=blocks.length-1; i>=0; i--) {
        if (blocks[i].name === name) {
          tree.blocks.remove(blocks[i]);
        }
      }
    });

    var _old = [this, this.add, [node]];
    var _new = [this, this.remove, [node]];
    project.history._add(new b3e.Command(_old, _new));

    project.history._endBatch();

    editor.trigger('noderemoved', node);
  };

  /**
   * Iterates over node list.
   */
  this.each = function(callback, thisarg) {
    Object.keys(project._nodes).forEach(function(key) {
      callback.call(thisarg, project._nodes[key]);
    });
  };

  this._applySettings = function(settings) {};
};
b3e.project.TreeManager = function(editor, project) {
  "use strict";

  /**
   * Adds a new tree to the project.
   */
  this.add = function(_id) {
    var tree;

    if (_id instanceof b3e.tree.Tree) {
      tree = _id;
      project.addChild(tree);
      editor.trigger('treeadded', tree);
      this.select(tree);
      
    } else {
      project.history._beginBatch();
      tree = new b3e.tree.Tree(editor, project);
      var root = tree.blocks.getRoot();
      project.addChild(tree);
      editor.trigger('treeadded', tree);

      if (_id) tree._id = _id;

      var node = {
        name     : tree._id,
        title    : root.title,
        category : 'tree', 
      };
      project.nodes.add(node, true);

      // select if this is the only tree
      this.select(tree);


      var _old = [this, this.remove, [tree]];
      var _new = [this, this.add, [tree]];
      project.history._add(new b3e.Command(_old, _new));
      project.history._endBatch();
    }

    return tree;
  };

  /**
   * Gets a tree by id.
   */
  this.get = function(tree) {
    if (typeof tree === 'string') {
      for (var i=0; i<project.children.length; i++) {
        if (project.children[i]._id === tree) {
          return project.children[i];
        }
      }

      return undefined;
    }

    return tree;
  };

  this.getSelected = function() {
    return project._selectedTree;
  };

  /**
   * Select a tree.
   */
  this.select = function(tree) {
    tree = this.get(tree);

    if (!tree || project.getChildIndex(tree)<0) return;
    if (project._selectedTree === tree) return;
    if (project._selectedTree) {
      project._selectedTree.visible = false;
      editor.trigger('treedeselected', project._selectedTree);
    }
    
    tree.visible = true;
    project._selectedTree = tree;
    editor.trigger('treeselected', tree);
  };

  /**
   * Removes a tree from the project.
   */
  this.remove = function(tree) {
    project.history._beginBatch();

    tree = this.get(tree);

    var idx = project.children.indexOf(tree);
    project.removeChild(tree);
    project.nodes.remove(tree._id);
    editor.trigger('treeremoved', tree);

    if (project.children.length === 0) {
      this.add();
    } else if (tree === project._selectedTree) {
      this.select(idx===0?project.children[idx]:project.children[idx-1]);
    }

    var _old = [this, this.add, [tree]];
    var _new = [this, this.remove, [tree]];
    project.history._add(new b3e.Command(_old, _new));
    project.history._endBatch();
  };

  /**
   * Iterates over tree list.
   */
  this.each = function(callback, thisarg) {
    project.children.forEach(callback, thisarg);
  };


  this._applySettings = function(settings) {
    this.each(function(tree) {
      tree._applySettings(settings);
    });
  };
};
b3e.tree.BlockManager = function(editor, project, tree) {
  "use strict";

  this._move = function(block, x, y) {
    block.x = x;
    block.y = y;
    block._redraw();

    // redraw connections linked to the entity
    if (block._inConnection) {
      block._inConnection._redraw();
    }
    for (var j=0; j<block._outConnections.length; j++) {
      block._outConnections[j]._redraw();
    }
  };

  /**
   * Add a block.
   */
  this.add = function(name, x, y) {
    // If name is a block
    var block;

    if (name instanceof b3e.Block) {
      block = name;
      block._snap();
      tree._blocks.addChild(block);
      editor.trigger('blockadded', block);

    }

    // Otherwise
    else {
      x = x||0; y = y||0;

      var node = name;
      if (typeof name === 'string') {
        node = project.nodes.get(name);
      }

      block = new b3e.Block(node);
      block._applySettings(editor._settings);
      block.x = x;
      block.y = y;
      block._snap();
      tree._blocks.addChild(block);

      tree.selection.deselectAll();
      tree.selection.select(block);

      editor.trigger('blockadded', block);
    }

    var _old = [this, this.remove, [block]];
    var _new = [this, this.add, [block, block.x, block.y]];
    project.history._add(new b3e.Command(_old, _new));

    return block;
  };

  this.get = function(block) {
    if (typeof block === 'string') {
      var blocks = tree._blocks.children;
      for (var i=0; i<blocks.length; i++) {
        if (blocks[i].id === block) {
          return blocks[i];
        }
      }
      return undefined;
    }

    return block;
  };
  this.getUnderPoint = function(x, y) {
    if (!x || !y) {
      var point = tree.view.getLocalPoint();
      x = point.x; y = point.y;
    }

    // Get block under the mouse
    var blocks = this.getAll();
    for (var i=blocks.length-1; i>=0; i--) {
      var block = blocks[i];

      if (block._hitTest(x, y)) return block;
    }
  };
  this.getSelected = function() {
    return tree._selectedBlocks.slice();
  };
  this.getAll = function() {
    return tree._blocks.children;
  };
  this.getRoot = function() {
    return tree._root;
  };
  this.update = function(block, template, merge) {
    var mustSave = !!template;

    var _oldValues = {
      name        : block.name,
      title       : block.title,
      description : block.description,
      properties  : block.properties,
    };

    template = template || {};
    var node = block.node;
    if (typeof template.name !== 'undefined') {
      block.name = template.name;
    } else {
      block.name = node.name || block.name;
    }
    if (typeof template.title !== 'undefined') {
      block.title = template.title;
    } else {
      block.title = node.title || block.title;
    }
    if (typeof template.description !== 'undefined') {
      block.description = template.description;
    } else {
      block.description = node.description || block.description;
    }
    if (typeof template.properties !== 'undefined') {
      block.properties = tine.merge({}, node.properties, template.properties);
    } else {
      block.properties = tine.merge({}, node.properties, block.properties);
    }
    block._redraw();

    var _newValues = {
      name        : block.name,
      title       : block.title,
      description : block.description,
      properties  : block.properties,
    };

    // redraw connections linked to the entity
    if (block._inConnection) {
      block._inConnection._redraw();
    }
    for (var j=0; j<block._outConnections.length; j++) {
      block._outConnections[j]._redraw();
    }
    
    if (!mustSave) project.history._lock();

    project.history._beginBatch();

    if (block.category === 'root') {
      project.nodes.update(tree._id, {title: block.title||'A behavior tree'});
    }

    var _old = [this, this.update, [block, _oldValues]];
    var _new = [this, this.update, [block, _newValues]];
    project.history._add(new b3e.Command(_old, _new));
    project.history._endBatch();
    
    if (!mustSave) project.history._unlock();

    editor.trigger('blockchanged', block);
  };
  this.remove = function(block) {
    project.history._beginBatch();
    tree._blocks.removeChild(block);

    if (block._inConnection) {
      tree.connections.remove(block._inConnection);
    }

    if (block._outConnections.length > 0) {
      for (var i=block._outConnections.length-1; i>=0; i--) {
        tree.connections.remove(block._outConnections[i]);
      }
    }

    if (block._isSelected) {
      tree.selection.deselect(block);
    }

    var _old = [this, this.add, [block, block.x, block.y]];
    var _new = [this, this.remove, [block]];
    project.history._add(new b3e.Command(_old, _new));

    project.history._endBatch();
    editor.trigger('blockremoved', block);
  };
  this.cut = function(block) {
    project.history._beginBatch();
    tree._blocks.removeChild(block);

    if (block._inConnection) {
      if (!block._inConnection._outBlock._isSelected) {
        tree.connections.remove(block._inConnection);
      } else {
        block._inConnection.visible = false;
      }
    }

    if (block._outConnections.length > 0) {
      for (var i=block._outConnections.length-1; i>=0; i--) {
        if (!block._outConnections[i]._inBlock._isSelected) {
          tree.connections.remove(block._outConnections[i]);
        } else {
          block._outConnections[i].visible = false;
        }
      }
    }

    var _old = [this, this.add, [block, block.x, block.y]];
    var _new = [this, this.remove, [block]];
    project.history._add(new b3e.Command(_old, _new));

    editor.trigger('blockremoved', block);
    project.history._endBatch();
  };
  this.each = function(callback, thisarg) {
    tree._blocks.children.forEach(callback, thisarg);
  };

  this._applySettings = function(settings) {
    this.each(function(block) {
      block._applySettings(settings);
    });
  };
};
b3e.tree.ConnectionManager = function(editor, project, tree) {
  "use strict";

  /** Needed to history manager */
  this._remove = function(block) {
    project.history._lock();
    this.remove(block._inConnection);
    project.history._unlock();
  };

  this.add = function(inBlock, outBlock) {
    var connection = new b3e.Connection();

    if (inBlock) {
      connection._inBlock = inBlock;
      inBlock._outConnections.push(connection);

      editor.trigger('blockconnected', inBlock, {
        connection: connection,
        type: 'outConnection',
        other: outBlock,
      });
    }

    if (outBlock) {
      connection._outBlock = outBlock;
      outBlock._inConnection = connection;

      editor.trigger('blockconnected', outBlock, {
        connection: connection,
        type: 'inConnection',
        other: inBlock,
      });
    }

    if (inBlock && outBlock) {
      var _old = [this, this._remove, [outBlock]];
      var _new = [this, this.add, [inBlock, outBlock]];
      project.history._add(new b3e.Command(_old, _new));
    }

    connection._applySettings(editor._settings);
    tree._connections.addChild(connection);

    // editor.trigger('connectionadded', connection);
    return connection;
  };

  this.remove = function(connection) {
    if (connection._inBlock && connection._outBlock) {
      var _old = [this, this.add, [connection._inBlock, connection._outBlock]];
      var _new = [this, this._remove, [connection._outBlock]];
      project.history._add(new b3e.Command(_old, _new));
    }

    if (connection._inBlock) {
      connection._inBlock._outConnections.remove(connection);
      connection._inBlock = null;
    }

    if (connection._outBlock) {
      connection._outBlock._inConnection = null;
      connection._outBlock = null;
    }

    tree._connections.removeChild(connection);
    editor.trigger('connectionremoved', connection);
  };
  this.each = function(callback, thisarg) {
    tree._connections.children.forEach(callback, thisarg);
  };

  this._applySettings = function(settings) {
    this.each(function(connection) {
      connection._applySettings(settings);
    });
  };
};

b3e.tree.EditManager = function(editor, project, tree) {
  "use strict";

  this._selectionToClipboard = function() {
    var clipboard = {blocks:{}, connections:[]};
    var blocks = tree._selectedBlocks;
    var i, j, block, other;

    // Copy block
    for (i=0; i<blocks.length; i++) {
      block = blocks[i];
      if (block.category === 'root') continue;
      
      var cp = {};
      cp.id = block.id;
      cp.node = block.node;
      cp.name = block.name;
      cp.title = block.title;
      cp.category = block.category;
      cp.description = block.description;
      cp.properties = block.properties;
      cp._settings = block._settings;
      cp.x = block.x;
      cp.y = block.y;
      clipboard.blocks[block.id] = cp;
    }

    // Copy connections
    for (i=0; i<blocks.length; i++) {
      block = blocks[i];
      
      if (block.category === 'root') continue;
      
      for (j=0; j<block._outConnections.length; j++) {
        other = block._outConnections[j]._outBlock;
        
        if (clipboard.blocks[other.id]) {
          clipboard.connections.push([block.id, other.id]);
        }
      }
    }

    project._clipboard = clipboard;
  };

  this.copy = function() {
    this._selectionToClipboard();
  };

  this.cut = function() {
    this._selectionToClipboard();

    project.history._beginBatch();
    for (var i=tree._selectedBlocks.length-1; i>=0; i--) {
      var block = tree._selectedBlocks[i];

      if (block.category != 'root') {
        tree.blocks.remove(tree._selectedBlocks[i]);
      }
    }
    project.history._endBatch();
    tree._selectedBlocks = [];

    console.log(project._clipboard);
  };

  this.paste = function() {
    if (project._clipboard === null) return;

    var i;
    var table = {};
    var blocks = [];

    project.history._beginBatch();

    // copy blocks
    for (var key in project._clipboard.blocks) {
      var spec = project._clipboard.blocks[key];
      var block = new b3e.Block(spec);

      spec.x += 50;
      spec.y += 50;
      block._applySettings(spec._settings);
      block.x = spec.x;
      block.y = spec.y;

      tree.blocks.add(block);
      table[key] = block;
      blocks.push(block);
    }

    // copy connections
    for (i=0; i<project._clipboard.connections.length; i++) {
      var connection = project._clipboard.connections[i];
      var inBlock = table[connection[0]];
      var outBlock = table[connection[1]];
      tree.connections.add(inBlock, outBlock);
    }

    // select the new nodes    
    tree.selection.deselectAll();
    for (i=0; i<blocks.length; i++) {
      tree.selection.select(blocks[i]);
    }

    project.history._endBatch();
  };

  this.duplicate = function() {
    project.history._beginBatch();
    var tempClipboard = project._clipboard;
    this.copy();
    this.paste();
    project._clipboard = tempClipboard;
    project.history._endBatch();
  };

  this.remove = function() {
    project.history._beginBatch();
    var root = null;
    for (var i=tree._selectedBlocks.length-1; i>=0; i--) {
      if (tree._selectedBlocks[i].category === 'root') {
        root = tree._selectedBlocks[i];
      } else {
        tree.blocks.remove(tree._selectedBlocks[i]);
      }
    }

    // tree.selection.deselectAll();
    // if (root) {
    //   tree.selection.select(root);
    // }
    project.history._endBatch();
  };

  this.removeConnections = function() {
    project.history._beginBatch();
    for (var i=0; i<tree._selectedBlocks.length; i++) {
      var block = tree._selectedBlocks[i];

      if (block._inConnection) {
        tree.connections.remove(block._inConnection);
      }

      if (block._outConnections.length > 0) {
        for (var j=block._outConnections.length-1; j>=0; j--) {
          tree.connections.remove(block._outConnections[j]);
        }
      }
    }
    project.history._endBatch();
  };

  this.removeInConnections = function() {
    project.history._beginBatch();
    for (var i=0; i<tree._selectedBlocks.length; i++) {
      var block = tree._selectedBlocks[i];

      if (block._inConnection) {
        tree.connections.remove(block._inConnection);
      }
    }
    project.history._endBatch();
  };

  this.removeOutConnections = function() {
    project.history._beginBatch();
    for (var i=0; i<tree._selectedBlocks.length; i++) {
      var block = tree._selectedBlocks[i];

      if (block._outConnections.length > 0) {
        for (var j=block._outConnections.length-1; j>=0; j--) {
          tree.connections.remove(block._outConnections[j]);
        }
      }
    }
    project.history._endBatch();
  };

  this._applySettings = function(settings) {
  };
};

b3e.tree.OrganizeManager = function(editor, project, tree) {
  "use strict";

  var lastLayout           = null;
  var depth                = 0;
  var leafCount            = 0;
  var horizontalSpacing    = 208;
  var verticalSpacing      = 88;
  var verticalCompensation = 42;
  var orderByIndex         = false;
  var connections          = []; // to redraw connections
  var blocks               = []; // to reposition blocks

  function stepH(block) {
    var x, y;
    blocks.push(block);

    // leaf
    if (block._outConnections.length === 0) {
      leafCount++;

      // leaf nodes have the position accord. to the depth and leaf cont.
      x = depth*horizontalSpacing;
      y = leafCount*verticalSpacing;
    }

    // internal node
    else {
      // internal nodes have the position acord. to the depth and the
      //    mean position of its children
      var ySum = 0;
      var conns;

      if (orderByIndex) {
        conns = block._outConnections;
      } else {
        // get connections ordered by y position
        conns = block._outConnections.slice(0);
        conns.sort(function(a, b) {
          return a._outBlock.y - b._outBlock.y;
        });
      }

      for (var i=0; i<conns.length; i++) {
        depth++;
        connections.push(conns[i]);
        ySum += stepH(conns[i]._outBlock);
        depth--;
      }

      x = depth*horizontalSpacing;
      y = ySum/block._outConnections.length;
    }

    block.x = x;
    block.y = y;

    return y;
  }

  function stepV(block) {
    var x, y;
    blocks.push(block);

    // leaf
    if (block._outConnections.length === 0) {
      leafCount++;

      // leaf nodes have the position accord. to the depth and leaf cont.
      x = leafCount*horizontalSpacing;
      y = depth*(verticalSpacing+verticalCompensation);
    }

    // internal node
    else {
      // internal nodes have the position acord. to the depth and the
      //    mean position of its children
      var xSum = 0;
      var conns;

      if (orderByIndex) {
        conns = block._outConnections;
      } else {
        // get connections ordered by y position
        conns = block._outConnections.slice(0);
        conns.sort(function(a, b) {
          return a._outBlock.x - b._outBlock.x;
        });
      }

      for (var i=0; i<conns.length; i++) {
        depth++;
        connections.push(conns[i]);
        xSum += stepV(conns[i]._outBlock);
        depth--;
      }

      x = xSum/block._outConnections.length;
      y = depth*(verticalSpacing+verticalCompensation);
    }

    block.x = x;
    block.y = y;

    return x;
  }

  this.organize = function(root, byIndex) {
    root = root || tree.blocks.getRoot();

    depth        = 0;
    leafCount     = 0;
    connections  = [];
    blocks       = [];
    orderByIndex = orderByIndex;

    var offsetX = root.x;
    var offsetY = root.y;

    var _olds = [];
    root.traversal(function(block) {
      _olds.push([block, block.x, block.y]);
    });

    if (editor._settings.get('layout') === 'horizontal') {
      stepH(root);
    } else {
      stepV(root);
    }

    offsetX -= root.x;
    offsetY -= root.y;

    var i;
    for (i=0; i<blocks.length; i++) {
      blocks[i].x += offsetX;
      blocks[i].y += offsetY;
      blocks[i]._snap();
    }

    for (i=0; i<connections.length; i++) {
      connections[i]._redraw();
    }

    var _news = [];
    root.traversal(function(block) {
      _news.push([block, block.x, block.y]);
    });

    project.history._beginBatch();
    for (i=0; i<blocks.length; i++) {
      var _old = [tree.blocks, tree.blocks._move, _olds[i]];
      var _new = [tree.blocks, tree.blocks._move, _news[i]];
      project.history._add(new b3e.Command(_old, _new));
    }
    project.history._endBatch();
  };

  this._applySettings = function(settings) {
    var layout = settings.get('layout');
    if (lastLayout && layout !== lastLayout) {
      this.organize();
    }
    lastLayout = layout;
  };
};

b3e.tree.SelectionManager = function(editor, project, tree) {
  "use strict";

  this.select = function(block) {
    if (block._isSelected) return;

    block._select();
    tree._selectedBlocks.push(block);

    editor.trigger('blockselected', block);
  };

  this.deselect = function(block) {
    if (!block._isSelected) return;

    block._deselect();
    tree._selectedBlocks.remove(block);

    editor.trigger('blockdeselected', block);
  };

  this.selectAll = function() {
    tree.blocks.each(function(block) {
      this.select(block);
    }, this);
  };

  this.deselectAll = function() {
    for (var i=tree._selectedBlocks.length-1; i>=0; i--) {
      this.deselect(tree._selectedBlocks[i]);
    }
  };

  this.invertSelection = function(block) {
    var blocks = (block)?[block]:tree.blocks.getAll();

    blocks.forEach(function(block) {
      if (block._isSelected) {
        this.deselect(block);
      } else {
        this.select(block);
      }
    }, this);
  };

  this.selectSubtree = function(block) {
    var blocks = (block)?[block]:tree._selectedBlocks;
    var fSelect = function(block) {
      blocks.remove(block);
      this.select(block);
    };

    while (blocks.length > 0) {
      blocks.pop().traversal(fSelect, this);
    }
  };

  this.deselectSubtree = function(block) {
    var blocks = (block)?[block]:tree._selectedBlocks;

    var fDeselect = function(block) {
      blocks.remove(block);
      this.deselect(block);
    };

    while (blocks.length > 0) {
      blocks.pop().traversal(fDeselect, this);
    }
  };

  this._applySettings = function(settings) {};

};

b3e.tree.ViewManager = function(editor, project, tree) {
  "use strict";

  this.reset = function() {
    tree.x = 0;
    tree.y = 0;
    tree.scaleX = 1;
    tree.scaleY = 1;
  };
  this.zoom = function(factor) {
    tree.scaleX = factor;
    tree.scaleY = factor;
  };
  this.zoomIn = function() {
    var min = editor._settings.get('zoom_min');
    var max = editor._settings.get('zoom_max');
    var step = editor._settings.get('zoom_step');
    
    var zoom = tree.scaleX;
    this.zoom(tine.clip(zoom+step, min, max));
  };
  this.zoomOut = function() {
    var min = editor._settings.get('zoom_min');
    var max = editor._settings.get('zoom_max');
    var step = editor._settings.get('zoom_step');
    
    var zoom = tree.scaleX;
    this.zoom(tine.clip(zoom-step, min, max));
  };
  this.pan = function(dx, dy) {
    tree.x += dx;
    tree.y += dy;
  };
  this.setCam = function(x, y) {
    tree.x = x;
    tree.y = y;
  };
  this.center = function() {
    var canvas = editor._game.canvas;
    var hw = canvas.width/2;
    var hh = canvas.height/2;
    this.setCam(hw, hh);
  };
  this.getLocalPoint = function(x, y) {
    if (typeof x == 'undefined') x = editor._game.mouse.x;
    if (typeof y == 'undefined') y = editor._game.mouse.y;
    return tree.globalToLocal(x, y);
  };

  this._applySettings = function(settings) {};
};

angular.module('app', [
  'ui.router',
  'ui.bootstrap',
  'ngAnimate',
  'templates'
])

.run(['$rootScope', '$window', '$state',
  function Execute($rootScope, $window, $state) {
    $rootScope.isDesktop = !!$window.process && !!$window.require;

    $rootScope.go = function(state, params) {
      $state.go(state, params);
    };
  }
])

.run(['$window', '$animate', '$location', '$document', '$timeout', 'settingsModel', 'projectModel',
  function Execute($window,
                   $animate,
                   $location,
                   $document,
                   $timeout,
                   settingsModel, 
                   projectModel) {

    // reset path
    $location.path('/');

    // add drop to canvas
    angular
      .element($window.editor._game.canvas)
      .attr('b3-drop-node', true);

    // initialize editor
    settingsModel.getSettings();
    projectModel
      .getRecentProjects()
      .then(function(projects) {
        
        function closePreload() {
          $timeout(function() {
            var element = angular.element(document.getElementById('page-preload'));
            $animate.addClass(element, 'preload-fade')
              .then(function() {
                element.remove();
              });
          }, 500);
        }

        if (projects.length > 0 && projects[0].isOpen) {
          projectModel
            .openProject(projects[0].path)
            .then(function() {
              closePreload();
            });
        } else {
          closePreload();
        }
      });
  }
]);

angular.module('app')

.config(['$stateProvider', '$urlRouterProvider',
  function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise('/dash/home');

    $stateProvider
      // Dash
      .state('dash', {
        url: '/dash',
        abstract: true,
        templateUrl: 'pages/dash/dash.html',
        controller: 'DashController',
        controllerAs: 'dash',
      })
      .state('dash.home', {
        url: '/home',
        templateUrl: 'pages/home/home.html',
        controller: 'HomeController',
        controllerAs: 'home',
      })
      .state('dash.projects', {
        url: "/projects",
        templateUrl: 'pages/projects/projects.html',
        controller: 'ProjectsController',
        controllerAs: 'projects',
      })
      .state('dash.settings', {
        url: "/settings",
        templateUrl: 'pages/settings/settings.html',
        controller: 'SettingsController',
        controllerAs: 'settings',
      })

      // Editor
      .state('editor', {
        url: "/editor",
        templateUrl: 'pages/editor/editor.html',
        controller: 'EditorController',
        controllerAs: 'editor',
      })
      .state('editor.editnode', {
        url: "/node/:name",
        templateUrl: 'pages/editor/modals/editnode.html',
        controller: 'EditNodeController',
        controllerAs: 'editnode',
      })
      .state('editor.export', {
        url: "/export/:type/:format",
        templateUrl: 'pages/editor/modals/export.html',
        controller: 'ExportController',
        controllerAs: 'export',
      })
      .state('editor.import', {
        url: "/import/:type/:format",
        templateUrl: 'pages/editor/modals/import.html',
        controller: 'ImportController',
        controllerAs: 'import',
      });
    }
]);
(function() {
  'use strict';

  angular
    .module('app')
    .controller('AppController', AppController);

  AppController.$inject = [
    '$scope',
    '$window',
    'dialogService'
  ];

  function AppController($scope,
                         $window,
                         dialogService) {

    // HEAD //
    var vm = this;

    _active();

    // BODY //
    function _active() {
      window.onbeforeunload = _onBeforeCloseBrowser;

      try {
        var gui = require('nw.gui');
        var win = gui.Window.get();

        win.on('close', function() {
          _onBeforeCloseDesktop(win);
        });
      } catch (e) {}
    }

    function _onBeforeCloseBrowser() {
      if ($window.editor.isDirty()) {
        return "Leaving now will erase your unsaved changes.";
      }
    }
    function _onBeforeCloseDesktop(win) {
      if ($window.editor.isDirty()) {
        dialogService
          .confirm(
            'Leave without saving?', 
            'If you proceed you will lose all unsaved modifications.', 
            null)
          .then(function() {
            win.close(true);
          });
        return false;
      } else {
        win.close(true);
      }

    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('MenubarController', MenubarController);

  MenubarController.$inject = [
    '$scope',
    '$window',
    '$state',
    'dialogService',
    'projectModel',
    'notificationService'
  ];

  function MenubarController($scope, 
                             $window,
                             $state,
                             dialogService,
                             projectModel,
                             notificationService) {
    var vm = this;
    vm.onNewTree           = onNewTree;
    vm.onCloseProject      = onCloseProject;
    vm.onSaveProject       = onSaveProject;
    vm.onExportProjectJson = onExportProjectJson;
    vm.onExportTreeJson    = onExportTreeJson;
    vm.onExportNodesJson   = onExportNodesJson;
    vm.onImportProjectJson = onImportProjectJson;
    vm.onImportTreeJson    = onImportTreeJson;
    vm.onImportNodesJson   = onImportNodesJson;
    vm.onUndo              = onUndo;
    vm.onRedo              = onRedo;
    vm.onCopy              = onCopy;
    vm.onCut               = onCut;
    vm.onPaste             = onPaste;
    vm.onDuplicate         = onDuplicate;
    vm.onRemove            = onRemove;
    vm.onRemoveAllConns    = onRemoveAllConns;
    vm.onRemoveInConns     = onRemoveInConns;
    vm.onRemoveOutConns    = onRemoveOutConns;
    vm.onAutoOrganize      = onAutoOrganize;
    vm.onZoomIn            = onZoomIn;
    vm.onZoomOut           = onZoomOut;
    vm.onSelectAll         = onSelectAll;
    vm.onDeselectAll       = onDeselectAll;
    vm.onInvertSelection   = onInvertSelection;

    _create();
    _activate();
    $scope.$on('$destroy', _destroy);

    function _activate() {
    }

    function _shortcut_projectclose(f) {
      if (!$scope.$$phase) { 
        $scope.$apply(function() { onCloseProject(); });
      } else {
        onCloseProject();
      }
      return false;
    }
    function _shortcut_projectsave(f) {
      if (!$scope.$$phase) { 
        $scope.$apply(function() { onSaveProject(); });
      } else {
        onSaveProject();
      }
      return false;
    }
    function _create() {
      Mousetrap.bind('ctrl+q', _shortcut_projectclose);
      Mousetrap.bind('ctrl+s', _shortcut_projectsave);
      Mousetrap.bind('ctrl+z', onUndo);
      Mousetrap.bind('ctrl+shift+z', onRedo);
      Mousetrap.bind('ctrl+c', onCopy);
      Mousetrap.bind('ctrl+v', onPaste);
      Mousetrap.bind('ctrl+x', onCut);
      Mousetrap.bind('ctrl+d', onDuplicate);
      Mousetrap.bind('del', onRemove);
      Mousetrap.bind('a', onAutoOrganize);
      Mousetrap.bind('ctrl+a', onSelectAll);
      Mousetrap.bind('ctrl+shift+a', onDeselectAll);
      Mousetrap.bind('ctrl+i', onInvertSelection);
    }
    function _destroy() {
      Mousetrap.unbind('ctrl+q', _shortcut_projectclose);
      Mousetrap.unbind('ctrl+s', _shortcut_projectsave);
      Mousetrap.unbind('ctrl+z', onUndo);
      Mousetrap.unbind('ctrl+shift+z', onRedo);
      Mousetrap.unbind('ctrl+c', onCopy);
      Mousetrap.unbind('ctrl+v', onPaste);
      Mousetrap.unbind('ctrl+x', onCut);
      Mousetrap.unbind('ctrl+d', onDuplicate);
      Mousetrap.unbind('del', onRemove);
      Mousetrap.unbind('a', onAutoOrganize);
      Mousetrap.unbind('ctrl+a', onSelectAll);
      Mousetrap.unbind('ctrl+shift+a', onDeselectAll);
      Mousetrap.unbind('ctrl+i', onInvertSelection);
    }

    function _getProject() {
      return $window.editor.project.get();
    }
    function _getTree() {
      var project = $window.editor.project.get();
      return project.trees.getSelected();
    }

    function onExportProjectJson() {
      $state.go('editor.export', {type:'project', format:'json'});
      return false;
    }
    function onExportTreeJson() {
      $state.go('editor.export', {type:'tree', format:'json'});
      return false;
    }
    function onExportNodesJson() {
      $state.go('editor.export', {type:'nodes', format:'json'});
      return false;
    }
    function onImportProjectJson() {
      $state.go('editor.import', {type:'project', format:'json'});
      return false;
    }
    function onImportTreeJson() {
      $state.go('editor.import', {type:'tree', format:'json'});
      return false;
    }
    function onImportNodesJson() {
      $state.go('editor.import', {type:'nodes', format:'json'});
      return false;
    }

    function onCloseProject() {
      function doClose() {
        projectModel.closeProject();
        $state.go('dash.projects');
      }

      if ($window.editor.isDirty()) {
        dialogService
          .confirm(
            'Leave without saving?', 
            'If you proceed you will lose all unsaved modifications.', 
            null)
          .then(doClose);
      } else {
        doClose();
      }

      return false;
    }
    function onSaveProject() {
      projectModel
        .saveProject()
        .then(function() {
          notificationService.success(
            'Project saved',
            'The project has been saved'
          );
        }, function() {
          notificationService.error(
            'Error',
            'Project couldn\'t be saved'
          );
        });
      return false;
    }
    function onNewTree() {
      var project = _getProject();
      project.trees.add();
      return false;
    }
    function onUndo() {
      var project = _getProject();
      project.history.undo();
      return false;
    }
    function onRedo() {
      var project = _getProject();
      project.history.redo();
      return false;
    }
    function onCopy() {
      var tree = _getTree();
      tree.edit.copy(); 
      return false;
    }
    function onCut() {
      var tree = _getTree();
      tree.edit.cut();
      return false;
    }
    function onPaste() {
      var tree = _getTree();
      tree.edit.paste();
      return false;
    }
    function onDuplicate() {
      var tree = _getTree();
      tree.edit.duplicate();
      return false;
    }
    function onRemove() {
      var tree = _getTree();
      tree.edit.remove();
      return false;
    }
    function onRemoveAllConns() {
      var tree = _getTree();
      tree.edit.removeConnections();
      return false;
    }
    function onRemoveInConns() {
      var tree = _getTree();
      tree.edit.removeInConnections();
      return false;
    }
    function onRemoveOutConns() {
      var tree = _getTree();
      tree.edit.removeOutConnections();
      return false;
    }
    function onAutoOrganize() {
      var tree = _getTree();
      tree.organize.organize();
      return false;
    }
    function onZoomIn() {
      var tree = _getTree();
      tree.view.zoomIn();
      return false;
    }
    function onZoomOut() {
      var tree = _getTree();
      tree.view.zoomOut();
      return false;
    }
    function onSelectAll() {
      var tree = _getTree();
      tree.selection.selectAll();
      return false;
    }
    function onDeselectAll() {
      var tree = _getTree();
      tree.selection.deselectAll();
      return false;
    }
    function onInvertSelection() {
      var tree = _getTree();
      tree.selection.invertSelection();
      return false;
    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('NodespanelController', NodespanelController);

  NodespanelController.$inject = [
    '$scope',
    '$window',
    'dialogService',
    'notificationService'
  ];

  function NodespanelController($scope, 
                                $window,
                                dialogService,
                                notificationService) {
    
    // HEAD //
    var vm = this;
    vm.nodes = null;
    vm.newTree = newTree;
    vm.select  = select;
    vm.remove  = remove;
    
    _create();
    _activate();
    $scope.$on('$destroy', _destroy);

    // BODY //
    function _activate() {
      vm.trees = [];
      vm.nodes = {
        composite : [],
        decorator : [],
        action    : [],
        condition : [],
      };

      var p = $window.editor.project.get();
      p.nodes.each(function(node) {
        if (node.category === 'tree') return;

        var list = vm.nodes[node.category];
        if (!list) return;
        list.push({
          name: node.name,
          title: _getTitle(node),
          isDefault: node.isDefault
        });
      });

      var selected = p.trees.getSelected();
      p.trees.each(function(tree) {
        var root = tree.blocks.getRoot();
        vm.trees.push({
          'id'       : tree._id,
          'name'     : root.title || 'A behavior tree',
          'active'   : tree===selected,
        });
      });
    }

    function _event(e) {
      setTimeout(function() {$scope.$apply(function() { _activate(); });}, 0);
    }

    function _create() {
      $window.editor.on('nodechanged', _event);
      $window.editor.on('noderemoved', _event);
      $window.editor.on('nodeadded', _event);
      $window.editor.on('treeadded', _event);
      $window.editor.on('blockchanged', _event);
      $window.editor.on('treeselected', _event);
      $window.editor.on('treeremoved', _event);
      $window.editor.on('treeimported', _event);
    }

    function _destroy() {
      $window.editor.off('nodechanged', _event);
      $window.editor.off('noderemoved', _event);
      $window.editor.off('nodeadded', _event);
      $window.editor.off('treeadded', _event);
      $window.editor.off('blockchanged', _event);
      $window.editor.off('treeselected', _event);
      $window.editor.off('treeremoved', _event);
      $window.editor.off('treeimported', _event);
    }

    function _getTitle(node) {
      var title = node.title || node.name;
      title = title.replace(/(<\w+>)/g, function(match, key) { return '@'; });
      return title;
    }

    function newTree() {
      var p = $window.editor.project.get();
      p.trees.add();
    }

    function select(id) {
      var p = $window.editor.project.get();
      p.trees.select(id);
    }

    function remove(id) {
      dialogService.
        confirm(
          'Remove tree?', 
          'Are you sure you want to remove this tree?\n\nNote: all blocks using this tree will be removed.'
        ).then(function() {
          var p = $window.editor.project.get();
          p.trees.remove(id);
          notificationService.success(
            'Tree removed',
            'The tree has been removed from this project.'
          );
        });
    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('PropertiespanelController', PropertiespanelController);

  PropertiespanelController.$inject = [
    '$scope',
    '$window'
  ];

  function PropertiespanelController($scope,
                                     $window) {
    var vm = this;
    vm.original = null;
    vm.block = null;
    vm.update = update;
    vm.keydown = keydown;

    _create();
    _activate();

    $scope.$on('$destroy', _destroy);

    function _activate() {
      var p = $window.editor.project.get();
      var t = p.trees.getSelected();
      var s = t.blocks.getSelected();

      if (s.length === 1) {
        vm.original = s[0];
        vm.block = {
          title       : vm.original.title,
          description : vm.original.description,
          properties  : tine.merge({}, vm.original.properties)
        };
      } else {
        vm.original = false;
        vm.block = false;
      }
    }
    function _event(e) {
      setTimeout(function() {$scope.$apply(function() { _activate(); });}, 0);
      
    }
    function _create() {
      $window.editor.on('blockselected', _event);
      $window.editor.on('blockdeselected', _event);
      $window.editor.on('blockremoved', _event);
      $window.editor.on('treeselected', _event);
      $window.editor.on('nodechanged', _event);
    }
    function _destroy() {
      $window.editor.off('blockselected', _event);
      $window.editor.off('blockdeselected', _event);
      $window.editor.off('blockremoved', _event);
      $window.editor.off('treeselected', _event);
      $window.editor.off('nodechanged', _event);
    }

    function keydown(e) {
      if (e.ctrlKey && e.keyCode == 90) {
        e.preventDefault();
      }

      return false;
    }

    function update() {
      var p = $window.editor.project.get();
      var t = p.trees.getSelected();
      t.blocks.update(vm.original, vm.block);
    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('TreespanelController', TreespanelController);

  TreespanelController.$inject = [
    '$scope',
    '$window',
    'dialogService',
    'notificationService'
  ];

  function TreespanelController($scope, 
                                $window,
                                dialogService,
                                notificationService) {

    // HEAD //
    var vm = this;
    vm.trees   = null;
    vm.newTree = newTree;
    vm.select  = select;
    vm.remove  = remove;
    
    _create();
    _activate();
    $scope.$on('$destroy', _destroy);

    // BODY //
    function _activate() {
      vm.trees = [];

      var p = $window.editor.project.get();
      var selected = p.trees.getSelected();
      p.trees.each(function(tree) {
        var root = tree.blocks.getRoot();
        vm.trees.push({
          'id'       : tree._id,
          'name'     : root.title || 'A behavior tree',
          'active'   : tree===selected,
        });
      });
    }

    function _event(e) {
      if (e.type !== 'blockchanged' || e._target.category === 'root') {
        if (!$scope.$$phase) { 
          $scope.$apply(function() { _activate(); });
        } else {
          _activate();
        }
      }
    }

    function _create() {
      $window.editor.on('blockchanged', _event);
      $window.editor.on('treeselected', _event);
      $window.editor.on('treeremoved', _event);
      $window.editor.on('treeimported', _event);
    }

    function _destroy() {
      $window.editor.off('blockchanged', _event);
      $window.editor.off('treeselected', _event);
      $window.editor.off('treeremoved', _event);
      $window.editor.off('treeimported', _event);
    }

    function newTree() {
      var p = $window.editor.project.get();
      p.trees.add();
    }

    function select(id) {
      var p = $window.editor.project.get();
      p.trees.select(id);
    }

    function remove(id) {
      dialogService.
        confirm(
          'Remove tree?', 
          'Are you sure you want to remove this tree?\n\nNote: all blocks using this tree will be removed.'
        ).then(function() {
          var p = $window.editor.project.get();
          p.trees.remove(id);
          notificationService.success(
            'Tree removed',
            'The tree has been removed from this project.'
          );
        });

    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('EditNodeController', EditNodeController);

  EditNodeController.$inject = [
    '$scope',
    '$window',
    '$state',
    '$stateParams',
    'dialogService',
    'notificationService'
  ];

  function EditNodeController($scope,
                              $window,
                              $state,
                              $stateParams,
                              dialogService,
                              notificationService) {
    var vm = this;
    vm.action = 'New';
    vm.node = null;
    vm.blacklist = null;
    vm.original = null;
    vm.save = save;
    vm.remove = remove;

    _active();

    function _active() {
      var p = $window.editor.project.get();

      if ($stateParams.name) {
        var node = p.nodes.get($stateParams.name);
        vm.node = node.copy();
        vm.original = node;
        vm.action = 'Update';
      } else {
        vm.node = new b3e.Node();
        vm.node.category = 'composite';
      }

      var blacklist = [];
      p.nodes.each(function(node) {
        if (node.name !== vm.node.name) {
          blacklist.push(node.name);
        }
      });
      vm.blacklist = blacklist.join(',');
    }

    function save() {
      var p = $window.editor.project.get();

      if (vm.original) {
        p.nodes.update(vm.original, vm.node);  
      } else {
        p.nodes.add(vm.node);
      }

      $state.go('editor');
      notificationService
        .success('Node created', 'Node has been created successfully.');
    }

    function remove() {
      dialogService.
        confirm(
          'Remove node?', 
          'Are you sure you want to remove this node?\n\nNote: all blocks using this node will be removed.'
        ).then(function() {
          var p = $window.editor.project.get();
          p.nodes.remove(vm.original);
          notificationService.success(
            'Node removed',
            'The node has been removed from this project.'
          );
          $state.go('editor');
        });
    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('ExportController', ExportController);

  ExportController.$inject = [
    '$scope',
    '$document',
    '$window',
    '$stateParams',
    'dialogService',
    'notificationService',
    'storageService'
  ];

  function ExportController($scope,
                            $document,
                            $window,
                            $stateParams,
                            dialogService,
                            notificationService,
                            storageService) {
    var vm = this;
    vm.type        = null;
    vm.format      = null;
    vm.compact     = '';
    vm.pretty      = '';
    vm.result      = null;
    vm.data        = null;
    vm.hideCompact = false;
    vm.showCompact = showCompact;
    vm.showPretty  = showPretty;
    vm.select      = select;
    vm.save        = save;

    _active();

    function _active() {
      vm.type = $stateParams.type;
      vm.format = $stateParams.format;

      var e = $window.editor.export;

      if (vm.type === 'project' && vm.format === 'json') {
        _createJson(e.projectToData());
      }
      else if (vm.type === 'tree' && vm.format === 'json') {
        _createJson(e.treeToData());
      }
      else if (vm.type === 'nodes' && vm.format === 'json') {
        _createJson(e.nodesToData());
      }
    }

    function _createJson(data) {
      vm.data = data;
      vm.compact = JSON3.stringify(data);
      vm.pretty = JSON3.stringify(data, null, 2);
      vm.result = vm.pretty;
    }

    function select(){
      var range = $document[0].createRange();
      range.selectNodeContents($document[0].getElementById('export-result'));
      var sel = $window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    function save() {
      dialogService
        .saveAs(null, ['.b3', '.json'])
        .then(function(path) {
          storageService
            .saveAsync(path, vm.pretty)
            .then(function() {
              notificationService.success(
                'File saved',
                'The file has been saved successfully.'
              );
            });
        });
    }

    function showCompact() {
      vm.result = vm.compact;
    }
    function showPretty() {
      vm.result = vm.pretty;
    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('ImportController', ImportController);

  ImportController.$inject = [
    '$scope',
    '$window',
    '$state',
    '$stateParams',
    'dialogService',
    'notificationService',
    'storageService'
  ];

  function ImportController($scope,
                            $window,
                            $state,
                            $stateParams,
                            dialogService,
                            notificationService,
                            storageService) {
    var vm = this;
    vm.type         = null;
    vm.format       = null;
    vm.open         = open;
    vm.loadFromFile = loadFromFile;
    vm.data         = '';

    _active();

    function _active() {
      vm.type = $stateParams.type;
      vm.format = $stateParams.format;
    }

    function loadFromFile() {
      dialogService
        .openFile(false, ['.b3', '.json'])
        .then(function(path) {
          storageService
            .loadAsync(path)
            .then(function(data) {
              vm.data = JSON3.stringify(data, null, 2);
            });
        });
    }
    function open() {
      var i = $window.editor.import;

      var data = JSON3.parse(vm.data);

      try {
        if (vm.type === 'project' && vm.format === 'json') {
          i.projectAsData(data);
        }
        else if (vm.type === 'tree' && vm.format === 'json') {
          i.treeAsData(data);
        }
        else if (vm.type === 'nodes' && vm.format === 'json') {
          i.nodesAsData(data);
        }
      } catch(e) {
        notificationService.error(
          'Invalid data',
          'The provided data is invalid.'
        );
      }

      $state.go('editor');
    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .directive('b3DragNode', dragNode);

  dragNode.$inject = [
    '$window'
  ];

  function dragNode($window) {
    var directive = {
      restrict    : 'A',
      link        : link,
    };
    return directive;

    function link(scope, element, attrs) {
      element.attr('draggable', 'true');

      element.bind('dragstart', function(e) {
        var canvas = $window.editor.preview(attrs.name);
        var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome')>-1;

        if (isChrome) {
          var img = document.createElement('img');
          img.src = canvas.toDataURL();

          // 10ms delay in order to proper create the image object
          // ugly hack =(
          var time = (new Date()).getTime();
          var delay = time + 10;
          while (time < delay) {
            time = (new Date()).getTime();
          }
          canvas = img;
        }

        e.dataTransfer.setData('name', attrs.name);
        e.dataTransfer.setDragImage(canvas, canvas.width/2, canvas.height/2);
      });
    }
  }

})();


// .directive('draggableNode', function($window) {
//   return {
//     restrict: 'A',
//     link: function(scope, element, attributes, controller) {
//       angular.element(element).attr("draggable", "true");
//       element.bind("dragstart", function(e) {
//         var img = $window.app.editor.preview(attributes.id.replace('node-', ''));
  
//         e.dataTransfer.setData('text', attributes.id);
//         e.dataTransfer.setDragImage(img, img.width/2, img.height/2);
//       });
//     }
//   }
// })

(function() {
  'use strict';

  angular
    .module('app')
    .directive('b3DropNode', dropNode);

  dropNode.$inject = [
    '$window'
  ];

  function dropNode($window) {
    var directive = {
      restrict    : 'A',
      link        : link,
    };
    return directive;

    function link(scope, element, attrs) {
      element.bind('dragover', function(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        return false;
      });
      element.bind('drop', function(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        
        var name = e.dataTransfer.getData('name');
        
        var project = $window.editor.project.get();
        var tree = project.trees.getSelected();
        var point = tree.view.getLocalPoint(e.clientX, e.clientY);
        tree.blocks.add(name, point.x, point.y);

        $window.editor._game.canvas.focus();
      });
    }
  }

})();

(function() {
  'use strict';

  angular
    .module('app')
    .directive('b3KeyTable', keytable)
    .controller('KeyTableController', KeyTableController);

  keytable.$inject = ['$parse'];
  function keytable($parse) {
    var directive = {
      require          : '^ngModel',
      restrict         : 'EA',
      replace          : true,
      bindToController : true,
      controller       : 'KeyTableController',
      controllerAs     : 'keytable',
      templateUrl      : 'directives/keytable.html',
      link: link
    };
    return directive;

    function link(scope, element, attrs) {
      // get the value of the `ng-model` attribute
      scope.keytable.heading = attrs.heading;
      scope.keytable._onChange = $parse(attrs.ngChange);

      var variable = attrs.ngModel;
      scope.$watch(variable, function(model) {
        scope.keytable.reset(model);
      });
    }
  }

  KeyTableController.$inject = ['$scope'];
  function KeyTableController($scope) {
    // HEAD //
    var vm = this;
    vm._onChange = null;
    vm.model  = $scope.keytable.model || $scope.model || null;
    vm.rows   = [];
    vm.add    = add;
    vm.remove = remove;
    vm.change = change;
    vm.reset  = reset;

    _activate();
    
    // BODY //
    function _activate() {
      if (vm.model) {
        for (var key in vm.model) {
          add(key, vm.model[key], false);
        }
      } else {
        vm.model = {};
      }
    }

    function reset(model) {
      vm.rows = [];
      vm.model = model;
      _activate();
    }

    function add(key, value, fixed) {
      vm.rows.push({key:key, value:value, fixed:fixed===true});
    }

    function remove(i) {
      vm.rows.splice(i, 1);
    }

    function change() {
      for (var key in vm.model){
        if (vm.model.hasOwnProperty(key)){
          delete vm.model[key];
        }
      }
      for (var i=0; i<vm.rows.length; i++) {
        var r = vm.rows[i];
        if (! r.key) continue;

        var value = r.value;
        if (!isNaN(value) && value !== '') {
          value = parseFloat(value);
        }

        vm.model[r.key] = value;
        
        if (vm._onChange) {
          vm._onChange($scope);
        }
      }
    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .directive('b3Tab', tab);

  function tab() {
    var directive = {
      require     : '^b3Tabset',
      restrict    : 'EA',
      scope       : {
        active : '=?',
        heading  : '@'
      },
      transclude  : true,
      templateUrl : 'directives/tab.html',
      link        : link,
    };
    return directive;

    function link(scope, element, attrs, ctrl) {
      scope.active = !!scope.active;
      ctrl.add(scope);
    }
  }

})();
(function() {
  'use strict';

  angular
    .module('app')
    .directive('b3Tabset', tabset);

  function tabset() {
    var directive = {
      restrict         : 'EA',
      transclude       : true,
      replace          : true,
      scope            : {},
      templateUrl      : 'directives/tabset.html',
      bindToController : true,
      controllerAs     : 'tabset',
      controller       : tabsetController,
    };
    return directive;
  }

  function tabsetController() {
    // HEAD //
    /* jshint validthis: true */
    var vm = this;
    vm.tabs = [];
    vm.add = add;
    vm.select = select;

    // BODY //
    function add(tab) {
      vm.tabs.push(tab);
    }

    function select(tab) {
      angular.forEach(vm.tabs, function(t) {
        if (t.active && t !== tab) {
          t.active = false;
        }
      });

      tab.active = true;
    }
  }
  

})();
(function () {
  'use strict';

  angular
    .module('app')
    .factory('projectModel', projectModel);

  projectModel.$inject = [
    '$q',
    '$rootScope',
    '$window',
    'storageService',
    'systemService',
    'localStorageService',
    'editorService'
  ];

  function projectModel($q,
                          $rootScope,
                          $window,
                          storageService,
                          systemService,
                          localStorageService,
                          editorService) {

    // HEAD //
    var recentPath = systemService.join(systemService.getDataPath(), 'recents.json');
    var recentCache = null;
    var currentProject = null;

    var service = {
      getRecentProjects   : getRecentProjects,
      newProject          : newProject,
      getProject          : getProject,
      saveProject         : saveProject,
      openProject         : openProject,
      closeProject        : closeProject,
      removeProject       : removeProject,
    };
    return service;

    // BODY //
    function _saveRecentProjects() {
      storageService.save(recentPath, recentCache);
    }
    function _updateRecentProjects(project) {
      if (project) {
        for (var i=recentCache.length-1; i>=0; i--) {
          if (recentCache[i].path === project.path) {
            recentCache.splice(i, 1);
          } else {
            recentCache[i].isOpen = false;
          }
        }

        var data = {
          name        : project.name,
          description : project.description,
          path        : project.path,
          isOpen      : true,
        };
        
        recentCache.splice(0, 0, data);
      } else {
        for (var j=0; j<recentCache.length; j++) {
          recentCache[j].isOpen = false;
        }
      }
      _saveRecentProjects();
    }
    function _setProject(project) {
      // Set current open project to the localStorage, so the app can open it
      //   during intialization
      currentProject = project;
      _updateRecentProjects(project);
      $rootScope.$broadcast('dash-projectchanged');
    }

    function getRecentProjects() {
      return $q(function(resolve, reject) {
        if (!recentCache) {
          var data;

          try {
            data = storageService.load(recentPath);
          } catch (e) {}

          if (!data) {
            data = [];
          }

          recentCache = data;
        }
        resolve(recentCache);
      });
    }
    function newProject(path, name) {
      return $q(function(resolve, reject) {
        var project = {
          name: name,
          description: '',
          data: [],
          path: path
        };

        editorService.newProject();
        project.data = editorService.exportProject();
        saveProject(project)
          .then(function() { 
            _setProject(project);
            resolve();
          });
      });
    }
    function getProject() {
      return currentProject;
    }
    function saveProject(project) {
      project = project || currentProject;
      project.data = editorService.exportProject();
      
      return $q(function(resolve, reject) {
        $window.editor.clearDirty();
        storageService.save(project.path, project);
        _updateRecentProjects(project);
        resolve();
      });
    }
    function openProject(path) {
      return $q(function(resolve, reject) {
        try {
          var project = storageService.load(path);
          editorService.openProject(project.data);
          _setProject(project);
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    }
    function closeProject() {
      return $q(function(resolve, reject) {
        $window.editor.clearDirty();
        editorService.closeProject();
        _setProject(null);
        resolve();
      }); 
    }
    function removeProject(path) {
      return $q(function(resolve, reject) {
        for (var i=0; i<recentCache.length; i++) {
          if (recentCache[i].path === path) {
            recentCache.splice(i, 1);
            break;
          }
        }

        _saveRecentProjects();
        resolve();
      });
    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .factory('settingsModel', settingsModel);

  settingsModel.$inject = [
    '$q',
    'storageService',
    'systemService',
    'editorService'
  ];

  function settingsModel($q,
                           storageService, 
                           systemService,
                           editorService) {

    // HEADER //
    var settingsPath = systemService.join(systemService.getDataPath(), 'settings.json');
    var settingsCache = null;

    var service = {
      getSettings   : getSettings,
      saveSettings  : saveSettings,
      resetSettings : resetSettings,
    };
    return service;

    // BODY //
    function getSettings() {
      return $q(function(resolve, reject) {
        if (!settingsCache) {
          var data;
          var defaultData = editorService.getDefaultSettings();
          try {
            data = storageService.load(settingsPath);
            editorService.applySettings(data);
          } catch (e) {}

          // Create if storage file does not exist
          if (!data) {
            data = defaultData;
            storageService.save(settingsPath, data);
          }

          settingsCache = tine.merge({}, defaultData, data);
        }

        resolve(settingsCache);
      });
    }
    function saveSettings(settings) {
      return $q(function(resolve, reject) {
        editorService.applySettings(settings);
        storageService.save(settingsPath, settings);
        settingsCache = settings;
        resolve();
      });
    }
    function resetSettings() {
      return $q(function(resolve, reject) {
        var settings = editorService.getDefaultSettings();
        storageService.save(settingsPath, settings);
        settingsCache = settings;
        editorService.applySettings(settings);
        resolve();
      });
    }
  }
})();
angular
  .module('app')
  .factory('dialogService', dialogService);

dialogService.$inject = ['$window', '$q', '$document', 'nodejsService'];

function dialogService($window, $q, $document, nodejsService) {
  var service = {
    alert         : alert,
    confirm       : confirm,
    prompt        : prompt,
    saveAs        : saveAs,
    openFile      : openFile,
    openDirectory : openDirectory
  };
  return service;

  function _callFileDialog(dialog) {
    return $q(function(resolve) {
      dialog.addEventListener('change', function() {
        resolve(dialog.value);
      });
      dialog.click();
    });
  }

  function alert(title, text, type, options) {
    options = options || {};
    options.title = title;
    options.text = text;
    options.type = type;
    options.customClass = type;

    return $q(function(resolve) { swal(options, function() { resolve(); }); });
  }
  function confirm(title, text, type, options) {
    options = options || {};
    options.title = title;
    options.text = text;
    options.type = type;
    options.customClass = type;
    options.showCancelButton = true;

    return $q(function(resolve, reject) {
      $window.swal(options, function(ok) {
        if (ok) {
          resolve();
        } else {
          reject();
        }
      });
    });
  }
  function prompt(title, text, type, placeholder, options) {
    options = options || {};
    options.title = title;
    options.text = text;
    options.type = type || 'input';
    options.inputPlaceholder = placeholder;
    options.customClass = type;
    options.showCancelButton = true;

    return $q(function(resolve, reject) {
      swal(options, function(val) { 
        if (val!==false) {
          resolve(val);
        } else {
          reject(val);
        }
      });
    });
  }
  function saveAs(placeholder, types) {
    return $q(function(resolve, reject) {
      var value = nodejsService.dialog.showSaveDialog({
        title: 'Save project as...',
        defaultPath: placeholder + '.b3',
        filters : [
          {name: 'Behavior3 File', extensions: ['b3', 'json']},
          {name: 'All Files', extensions: ['*']}
        ]
      });
      if (value) {
        resolve(value);
      } else {
        reject();
      }
    });
  }
  function openFile(multiple, types) {
    return $q(function(resolve, reject) {
      var value = nodejsService.dialog.showOpenDialog({
        title: 'Open file...',
        multiSelections: multiple,
        properties: ['openFile'],
        filters : [
          {name: 'Behavior3 File', extensions: ['b3', 'json']},
          {name: 'All Files', extensions: ['*']}
        ]
      });

      if (value) {
        if (!multiple) {
          value = value[0];
        }
        console.log(value);
        resolve(value);
      } else {
        reject();
      }
    });
  }
  function openDirectory() {
    return $q(function(resolve, reject) {
      var value = nodejsService.dialog.showOpenDialog({
        title: 'Open directory...',
        properties: ['openDirectory']
      });
      if (value) {
        resolve(value);
      } else {
        reject();
      }
    });
  }
  
}
angular
  .module('app')
  .factory('editorService', editorService);

editorService.$inject = ['$window'];

function editorService($window) {
  var service = {
    getDefaultSettings : getDefaultSettings,
    applySettings      : applySettings,
    newProject         : newProject,
    openProject        : openProject,
    closeProject       : closeProject,
    exportProject      : exportProject,
  };
  return service;

  function getDefaultSettings() {
    return $window.b3e.DEFAULT_SETTINGS;
  }
  function applySettings(settings) {
    $window.editor.applySettings(settings);
  }

  function newProject() {
    $window.editor.project.create();
  }
  function openProject(data) {
    $window.editor.project.open(data);
  }
  function closeProject() {
    $window.editor.project.close();
  }

  function exportProject() {
    return $window.editor.export.projectToData();
  }
}
angular
  .module('app')
  .factory('nodejsService', nodejsService);

nodejsService.$inject = ['$window'];

function nodejsService($window) {
  var ok = !!$window.require;
  var remote = (ok?$window.require('remote'):null);
  var service = {
    ok   : ok,
    fs   : (ok?$window.require('fs'):null),
    path : (ok?$window.require('path'):null),
    dialog : (ok?remote.require('dialog'):null),
  };
  return service;

}
angular
  .module('app')
  .factory('notificationService', notificationService);

notificationService.$inject = ['$window', '$timeout', '$compile', '$rootScope', '$sce'];

function notificationService($window, $timeout, $compile, $rootScope, $sce) {
  var elementBuffer = [];
  var service = {
    notify  : notify,
    simple  : simple,
    success : success,
    error   : error,
    info    : info,
    warning : warning,
  };
  return service;

  function _reposite() {
    var verticalSpacing = 10;
    var lastBottom = 20;

    for(var i=elementBuffer.length-1; i>=0; i--) {
      var element = elementBuffer[i];
      var height = parseInt(element[0].offsetHeight);
      
      var bottom = lastBottom;
      lastBottom = bottom+height+verticalSpacing;

      element.css('bottom', bottom+'px');
    }
  }

  function _note(config) {
    var TEMPLATE = ''+
    '<div class="notification" ng-class="type">'+
    '  <div class="notification-icon" ng-show="icon"><i class="fa fa-fw" ng-class="icon"></i></div>'+
    '  <div class="notification-content" ng-class="{\'has-icon\': icon}">' +
    '    <div class="notification-title" ng-show="title" ng-bind-html="title"></div>'+
    '    <div class="notification-message" ng-bind-html="message"></div>'+
    '  </div>' +
    '</div>';

    var DEFAULT = {
      type    : 'default',
      title   : '',
      message : '',
      icon    : false,
      delay   : 3000,
    };

    // Default parameters
    config = tine.merge({}, DEFAULT, config);

    // Set scope variables to fill the template
    var scope = $rootScope.$new();
    scope.type = config.type;
    scope.title = $sce.trustAsHtml(config.title);
    scope.message = $sce.trustAsHtml(config.message);
    scope.icon = config.icon;
    scope.delay = config.delay;

    // Create the DOM element and add events
    var element = $compile(TEMPLATE)(scope);
    element.bind('webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd click', function(e) {
      e = e.originalEvent || e;
      if (e.type==='click' || element.hasClass('killed')) {
        element.remove();
        elementBuffer.remove(element);
        _reposite();
      }
    });

    if (angular.isNumber(config.delay)) {
      $timeout(function() {
        element.addClass('killed');
      }, config.delay);
    }
    
    $timeout(function() {
      element.addClass('started');
      _reposite();
    }, 0);

    elementBuffer.push(element);
    angular.element(document.getElementsByTagName('body')).append(element);
  }

  function notify(config) {
    _note(config);
  }
  function simple(title, message) {
    _note({title:title, message:message, type:'default'});
  }
  function success(title, message) {
    _note({title:title, message:message, icon:'fa-check', type:'success'});
  }
  function error(title, message) {
    _note({title:title, message:message, icon:'fa-close', type:'error'});
  }
  function info(title, message) {
    _note({title:title, message:message, icon:'fa-info', type:'info'});
  }
  function warning(title, message) {
    _note({title:title, message:message, icon:'fa-warning', type:'warning'});
  }
}
angular
  .module('app')
  .factory('systemService', systemService);

systemService.$inject = ['$window', 'nodejsService'];

function systemService($window, nodejsService) {
  var isDesktop = !!$window.process;
  var service = {
    isDesktop   : isDesktop,
    getDataPath : getDataPath,
    join        : join,
  };
  return service;

  function _createIfNonExist(path) {
    try {
      var s = nodejsService.fs.statSync(path);
    } catch (e) {
      nodejsService.fs.mkdirSync(path);
    }
  }
  function getDataPath() {
    if (isDesktop) {
      var datapath = process.env.APPDATA;
      if (!datapath) {
        datapath = process.env.HOME + '/.behavior3';
      }

      var path = join(datapath, 'b3editor');
      _createIfNonExist(datapath);
      _createIfNonExist(path);
      return path;
    } else {
      return 'b3editor';
    }
  }
  function join() {
    if (isDesktop) {
      return nodejsService.path.join.apply(nodejsService.path, arguments);
    } else {
      var s = arguments[0];
      for (var i=1; i<arguments.length; i++) {
        s += '-'+arguments[i];
      }
      return s;
    }
  }
}
(function() {
  'use strict';

  angular
    .module('app')
    .directive('blacklist', blacklist);

  function blacklist() {
    var directive = {
      require     : 'ngModel',
      restrict    : 'A',
      link        : link,
    };
    return directive;

    function link(scope, element, attrs, ctrl) {
      var blacklist = attrs.blacklist.split(',');
      
      //For DOM -> model validation
      ctrl.$parsers.unshift(function(value) {
         var valid = blacklist.indexOf(value) === -1;
         ctrl.$setValidity('blacklist', valid);
         return valid ? value : undefined;
      });

      //For model -> DOM validation
      ctrl.$formatters.unshift(function(value) {
         ctrl.$setValidity('blacklist', blacklist.indexOf(value) === -1);
         return value;
      });
    }
  }

})();
angular
  .module('app')
  .factory('fileStorageService', fileStorageService);

fileStorageService.$inject = ['nodejsService'];

function fileStorageService(nodejsService) {
  var ok = nodejsService.ok;
  var fs = nodejsService.fs;

  var service = {
    ok     : ok,
    save   : save,
    load   : load,
    remove : remove
  };
  return service;

  function save(path, data) {
    if (typeof data !== 'string') {
      try { data = JSON3.stringify(data); } catch (e) {}
    }

    var file = fs.openSync(path+'~', 'w');
    fs.writeSync(file, data);
    fs.closeSync(file);

    // Rename must be async to override correctly.
    fs.rename(path+'~', path);
  }
  function load(path) {
    var data = fs.readFileSync(path, 'utf-8');
    try { data = JSON3.parse(data); } catch (e) {}
    return data;
  }
  function remove(path) {
    
  }
}
angular
  .module('app')
  .factory('localStorageService', localStorageService);

localStorageService.$inject = ['$window'];

function localStorageService($window) {
  var service = {
    ok     : !!$window.localStorage,
    save   : save,
    load   : load,
    remove : remove
  };
  return service;

  function save(path, data) {
    try { data = JSON.stringify(data); } catch (e) {}
    $window.localStorage[path] = data;
  }
  function load(path) {
    var data = $window.localStorage[path];
    try { data = JSON.parse(data); } catch (e) {}
    return data;
  }
  function remove(path) {
    delete $window.localStorage[path];
  }
}
angular
  .module('app')
  .factory('storageService', storageService);

storageService.$inject = ['$q', 'localStorageService', 'fileStorageService'];

function storageService($q, localStorageService, fileStorageService) {
  var storage = (fileStorageService.ok?fileStorageService:localStorageService);
  
  var service = {
    save        : save,
    saveAsync   : saveAsync,
    load        : load,
    loadAsync   : loadAsync,
    remove      : remove,
    removeAsync : removeAsync,
  };
  return service;

  function save(path, data) {
    storage.save(path, data);
  }
  function saveAsync(path, data) {
    return $q(function(resolve, reject) {
      try {
        storage.save(path, data);
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  }
  function load(path) {
    return storage.load(path);
  }
  function loadAsync(path) {
    return $q(function(resolve, reject) {
      try {
        var data = storage.load(path);
        resolve(data);
      } catch (e) {
        reject(e);
      }
    });
  }
  function remove(path) {
    storage.remove(path);
  }
  function removeAsync(path) {
    return $q(function(resolve, reject) {
      try {
        storage.remove(path);
        resolve();
      } catch (e) {
        reject(e);
      }
    });
  }
}
(function() {
  'use strict';

  angular
    .module('app')
    .controller('DashController', DashController);

  DashController.$inject = [
    '$scope',
    'projectModel'
  ];

  function DashController($scope, projectModel) {
    var vm = this;
    vm.project = null;
    _activate();

    function _activate() {
      vm.project = projectModel.getProject();
    }
    $scope.$on('dash-projectchanged', function() {
      _activate();
    });
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('HomeController', HomeController);

  HomeController.$inject = [
  ];

  function HomeController() {
    var vm = this;

    _active();

    function _active() {
      // var e = document.getElementById('prld');
      // if (e) e.remove();
    }
  }

})();
angular
  .module('app')
  .controller('EditorController', EditorController);

EditorController.$inject = [];

function EditorController() {
  
}
(function() {
  'use strict';

  angular
    .module('app')
    .controller('ProjectsController', ProjectsController);

  ProjectsController.$inject = [
    '$state',
    '$window',
    'dialogService',
    'systemService', 
    'notificationService',
    'projectModel'
  ];

  function ProjectsController($state,
                              $window,
                              dialogService, 
                              systemService,
                              notificationService,
                              projectModel) {

    // HEAD //
    var vm = this;
    vm.recentProjects = [];
    vm.isDesktop = null;

    vm.newProject = newProject;
    vm.openProject = openProject;
    vm.editProject = editProject;
    vm.saveProject = saveProject;
    vm.closeProject = closeProject;
    vm.removeProject = removeProject;

    _activate();

    // BODY //
    function _activate() {
      vm.isDesktop = systemService.isDesktop;
      projectModel
        .getRecentProjects()
        .then(function(recents) {
          vm.recentProjects = recents;
        });
    }

    function _newProject(path, name) {
      projectModel
        .newProject(path, name)
        .then(function() {
          $state.go('editor');
        });
    }

    function newProject() {
      function doNew() {
        // Get project name
        dialogService
          .prompt('New project', null, 'input', 'Project name')
          .then(function(name) {
            // If no name provided, abort
            if (!name) {
              notificationService.error(
                'Invalid name',
                'You must provide a name for the project.'
              );
              return;
            }

            // If desktop, open file dialog
            if (vm.isDesktop) {
              var placeholder = name.replace(/\s+/g, "_").toLowerCase();

              dialogService
                .saveAs(placeholder, ['.b3', '.json'])
                .then(function(path) {
                  _newProject(path, name);
                });
            } else {
              var path = 'b3projects-'+b3.createUUID();  
              _newProject(path, name);
            }
          });
      }

      if ($window.editor.isDirty()) {
        dialogService
          .confirm(
            'Leave without saving?', 
            'If you proceed you will lose all unsaved modifications.', 
            null, {closeOnConfirm: false})
          .then(doNew);
      } else {
        doNew();
      }
    }

    function _openProject(path) {
      projectModel
        .openProject(path)
        .then(function() {
          $state.go('editor');
        }, function() {
          notificationService.error(
            'Invalid file',
            'Couldn\'t open the project file.'
          );
        });
    }
    function openProject(path) {
      function doOpen() {
        if (path) {
          _openProject(path);
        } else {
          dialogService
            .openFile(false, ['.b3', '.json'])
            .then(function(path) {
              _openProject(path);
            });
        }
      }

      if ($window.editor.isDirty()) {
        dialogService
          .confirm(
            'Leave without saving?', 
            'If you proceed you will lose all unsaved modifications.')
          .then(doOpen);
      } else {
        doOpen();
      }
    }

    function editProject() {
      var project = projectModel.getProject();

      dialogService
        .prompt('Rename project', null, 'input', project.name)
        .then(function(name) {
          // If no name provided, abort
          if (!name) {
            notificationService.error(
              'Invalid name',
              'You must provide a name for the project.'
            );
            return;
          }

          project.name = name;
          projectModel
            .saveProject(project)
            .then(function() {
              _activate();
              notificationService.success(
                'Project renamed',
                'The project has been renamed successfully.'
              );
            });
        });
    }

    function saveProject() {
      projectModel
        .saveProject()
        .then(function() {
          notificationService.success(
            'Project saved',
            'The project has been saved'
          );
        }, function() {
          notificationService.error(
            'Error',
            'Project couldn\'t be saved'
          );
        });
    }

    function closeProject() {
      function doClose() {
        projectModel.closeProject();
      }

      if ($window.editor.isDirty()) {
        dialogService
          .confirm(
            'Leave without saving?', 
            'If you proceed you will lose all unsaved modifications.', 
            null)
          .then(doClose);
      } else {
        doClose();
      }
    }

    function removeProject(path) {
      dialogService.
        confirm(
          'Remove project?', 
          'Are you sure you want to remove this project?'
        ).then(function() {
          projectModel
            .removeProject(path)
            .then(function() {
              _activate();
              notificationService.success(
                'Project removed',
                'The project has been removed from editor.'
              );
            });
        });
    }
  }
})();
(function() {
  'use strict';

  angular
    .module('app')
    .controller('SettingsController', SettingsController);

  SettingsController.$inject = [
    'notificationService',
    'settingsModel',
    'dialogService',
  ];

  function SettingsController(notificationService,
                              settingsModel,
                              dialogService) {

    // HEADER //
    var vm = this;
    vm.settings = {};
    vm.saveSettings = saveSettings;
    vm.resetSettings = resetSettings;

    _activate();

    // BODY //
    function _activate() {
      settingsModel
        .getSettings()
        .then(function(settings) {
          vm.settings = settings;
        });
    }

    function saveSettings() {
      settingsModel
        .saveSettings(vm.settings)
        .then(function() {
          notificationService.success(
            'Settings saved',
            'The editor settings has been updated.'
          );
        });
    }

    function resetSettings() {
      dialogService.confirm(
        'Reset Settings?',
        'Are you sure you want to reset to the default settings?'
      ).then(function() {
        settingsModel
          .resetSettings()
          .then(function() {
            notificationService.success(
              'Settings reseted',
              'The editor settings has been updated to default values.'
            );
            _activate();
          });
      });
    }
  }
})();
var editor;

function startApp() {
  var domProgress = document.getElementById('page-preload');
  
  editor = new b3e.editor.Editor();
  angular.bootstrap(document, ['app']);
}